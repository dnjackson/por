[{"content":"Sometimes an app would be enormously improved if a single essential concept were added.\nAll email clients, for example, would benefit from a robust concept for identifying the people you communicate with. In Apple Mail, searching for messages from particular users is a nightmare: I type the user’s name into the search box and it matches multiple email addresses, which I then have to filter on one by one. And often even that fails to reveal the message I was looking for, because the from field of the message happened not to include the person’s name.\nIn this example, Apple is not to blame (although the design could surely be improved). Without a universal scheme (such as a public key infrastructure for email names and addresses), there’s no easy way to identify users. Even within a more closed network like Gmail you still have the problem of identifying users from outside the system.\nIt’s more surprising when a crucial concept is missing for no apparent reason. I’ve been thinking about Zoom recently and how, despite being a generally wonderful service, it has some design flaws that make the entire experience of using it much less pleasant.\nA new concept for Zoom The missing concept that I have in mind might be called MeetingList. Its purpose would be to let you join meetings more easily, without having to store and recall a meeting identifier externally. The operational principles might be:\n When you join a meeting, the meeting identifier is added to the meeting list, and after the meeting ends, you can restart or rejoin the meeting by clicking on it. When you schedule an upcoming meeting, the meeting identifier is added to the list, and you can start or join when the time comes around by clicking on it. If someone else schedules a meeting, they can send you the meeting identifier, and you can add the identifier to your meeting list, and then subsequently start or join by clicking on it.  This concept would surely not be difficult to implement. OPs (1) and (3) do suggest that a meeting identifier might carry (either within the identifier or by a binding in the cloud) the date and time, host and title of a meeting; OP (2) doesn’t require this, since the meeting has just been created by this user.\nZoom already includes a fledgling form of this concept that supports only OP (2), but it’s not very useful since only those meetings you happened to create yourself are included:\nThe fuller concept would offer many advantages:\n When a meeting ends prematurely, you would be able to rejoin easily without having to recall the meeting identifier. To join a meeting scheduled by someone else, you wouldn’t need to dig around in your email or calendar to find the link. Zoom could provide notifications for meetings about to happen; you wouldn’t need to rely on separate calendar notifications (or give Zoom access to your calendar, which only works anyway for Google and Outlook calendars).  This concept would be easy for users to understand; it’s a simple extension of the familiar CallHistory concept used by all communication apps (and by Zoom itself for its phone call feature).\nAn Achilles heel for Zoom? Including this concept might be important not only because it makes Zoom easier to use. Without it, Zoom is more vulnerable to competition from related products (such as Microsoft Teams, Google Meet and Apple FaceTime).\nWhen Zoom first became popular, its concept of a meeting with a persistent identifier was critical to widespread adoption. Unlike other video calling apps at the time, notably Skype and FaceTime, you could connect with someone without them having to have an app installed and being ready to receive your call. You simply sent a URL containing the meeting identifier, and if they accessed it at a pre-arranged time, they could connect to you through the Zoom app in a browser.\nThis was a brilliant idea, and made Zoom feel lightweight and easy. There was no commitment to a platform. In contrast, Teams (for example) required you to register an account and join a team, and it was hard to take calls in more than one team. A common piece of advice at the time recommended assigning a separate browser to each of your teams in order to work around bugs in switching between teams!\nSince then, Microsoft has fixed many of the problems in Teams, and incorporated Zoom’s meeting identifier concept.\nZoom’s very advantage over its competitors—that it was easier to use because there was no platform commitment—may become its downfall. If users don’t have a way to manage all their Zoom meetings within Zoom itself, and have to resort to using external calendars and tools, Zoom becomes simply a video calling technology.\nZoom’s advantage in video quality (and better handling of bandwidth glitches) is shrinking as its competitors improve their technology. If Apple, Google and Microsoft continue to unify and integrate the features they offer within their own platforms, it will be easier and more tempting just to schedule meetings there, leaving Zoom out in the cold.\nThis post was inspired by a discussion with David Jackson.\n","permalink":"https://essenceofsoftware.com/posts/missing-concept/","summary":"How the omission of a single concept may threaten the success of an app, with Zoom as an example.","title":"For Want of a Nail…"},{"content":"If user experience runs deeper than the user interface, we need a way to talk about an app that isn’t just visual, and that captures behavior in a more fundamental way.\nProgrammers think in terms of complicated things like objects, callbacks, streams, functionals, and so on. They’re essential for structuring code, but for behavior a much simpler model is effective.\nState machines That model is the state machine. You’ve probably come across state machines, either in a class about the theory of computation, or seeing diagrams like this:\nThis diagram describes the state machine of a shopping cart. You start with an empty cart; adding an item produces a non-empty cart; then you can add and remove more items; checkout; and then return to the initial state.\nDiagrams like this are useful for capturing basic control flow. But they’re not rich enough for modeling behavior, because the number of states must be finite (and small enough to draw!). This diagram doesn’t say that the order you submit when you checkout contains the items you added and didn’t remove. And because individual items aren’t tracked, it needs some non-determinism to model the fact that when you remove an item from a non-empty cart you might end up back with an empty cart (if it was the last item) or you might not (if it wasn’t).\nA richer state machine model has a set of states, usually infinite, and a set of parameterized actions over the states. The states can be defined with some variables whose values are either primitives (such as integers and strings) or more often structures (such as sets and relations).\nStates The variables representing the state of an online store, for example, might include one holding the number of each item in stock:\nstock: Item -\u0026gt; one Number  sets of pending and fulfilled orders for each user:\npending, fulfilled: User -\u0026gt; set Order  a shopping cart for each user:\ncart: User -\u0026gt; one Cart  and, for each cart or order, the items it contains:\nitems: (Cart + Order) -\u0026gt; set Item  The value of each of these variables is a relation. The fulfilled variable, for example, is a set of pairs of the form (u, o) where u is a user and o is one of u’s fulfilled orders. Viewed as a table, there’s a separate row for each user and order. So if there are two fulfilled orders for Alice and one for Bob, the table might look like this:\n   User Order     Alice Order_1   Alice Order_3   Bob Order_2    Actions The actions read and write these states. Here’s an action for adding an item to a cart:\nadd (c: Cart, i: Item) i.stock \u0026gt; 0 c.items += i i.stock -= 1  The first line says the item has to be in stock; the second adds the item to the card; and the third reduces the stock of that item by one. An occurrence of an action is defined by an action name and some parameters. You can imagine drawing an infinite state machine diagram, but instead of labels like add (as above) we have labels like add (Cart_0, Item_1).\nRemoving an item from a cart looks like this:\nremove (c: Cart, i: Item) i in c.items c.items -= i i.stock += 1  When you checkout, a fresh order is created and made pending, the cart is deleted from the user’s carts, and the order is given the set of items that were in the cart:\ncheckout (u: User, c: Cart, o: Order) fresh o u.pending += o c in u.carts u.carts -= c o.items := c.items  Finally, when an order gets fulfilled, it’s moved from the set of pending orders to the set of fulfilled orders:\nfulfill (u: User, o: Order) o in u.pending u.pending -= o u.fulfilled += o  ER diagrams An ER diagram offers a nice way to show the state variables:\nThere are a few differences from the textual declarations. I’ve used symbols rather than words for multiplicity (! in place of one, for example). I’ve shown the multiplicity on both ends of a relation: the ! on the source end of the cart arrow says that each cart belongs to one user. You can do both of these textually too. The diagram doesn’t naturally accommodate unions of sets, so for the items relation I introduced a superset called Bag, with each Bag being either a Cart of an Order.\nThese diagrams are very lightweight and contain lots of information. Working out the details of the state as you the draw the diagram always reveals interesting questions. Can a user have more than one cart, for example? That’s certainly possible for Amazon, because a client-side cart is created before you even log in.\nWhat’s the point?  UI-independent view. Viewing an app in terms of its state and actions lets you think about its behavior concretely, but without having to consider the details of the user interface. And when you come to design the UI, you can ask yourself how to map the states and actions to UI views and widgets. More succinct than use cases. A use case can be useful for describing the details of a workflow, but often a single action will suffice. The checkout action, for example, could encompass all the steps in checking out a shopping cart, and the flow would be better described using wireframes than text. For capturing a fuller journey (that a user adds and removes items from a cart, then checks it out, then the order is fulfilled), I recommend using an operational principle written in terms of actions. Path to implementation. It’s easy to extract a relational database schema from the ER diagram. OMT showed how to do this systematically. You can also generate a class hierarchy for an object-oriented approach. Small details expose big issues. The biggest advantage of writing down a state machine is that as you work out small details you inevitably encounter questions that expose serious design issues. For example, when I wrote the add action, I had to decide whether it should check the stock of the item, and if so, whether it should decrement it. I decided to do both, which means that (a) you can only add an item that is in stock; and (b) you’re assured that when you checkout, the item you wanted won’t have been taken by someone else. But this convenience for the user comes at a cost for the company, because it means that items will be shown as unavailable when they haven’t yet been paid for. And there will need to be a way to return an item to the inventory if too much time elapses with the cart not being checked out.  Some technical notes   History. This kind of state machine model was introduced by the Z Notation in the late 1970s, and became universal in all formal modeling languages (VDM, B, TLA and my own language Alloy).\n  Global state. The state represents the entire global state of the app, frontend and backend. A state machine can describe a distributed system too. Butler Lampson shows how to do this in his course notes on operating system design.\n  Notational nitpicks. The notation I used in the example is mostly from Alloy, with a shorthand for updating a relation. The statement c.items -= i would be written c.items’ = c.items + i in Alloy. There’s a crafty overloading going on in the treatment of the inventory counting: since the stock variable maps each item to exactly one number, I’ve written i.stock += 1 for i.stock’ = plus(i.stock, 1), with the + meaning integer additional and not the set union it usually means in Alloy.\n  Visible state. In many formal methods, the state is assumed to be hidden, and the user’s view of the state is represented by observer actions that produce outputs but don’t update the state. It’s easier to just assume that the state is by default visible to the user, and to describe how and when the user can view the state as part of the user interface mapping.\n  Relations and RDBs. Relations don’t need to be binary. But relations of higher-arity should only be used when there’s a genuine need to relate more than two things: in RDB terms, the relations should be fully normalized. For example, to allow more than one of a given item in a cart or order, we could declare a 3-place relation containing the tuple (c, i, n) when cart c has n copies of item i:\n items: (Cart + Order) -\u0026gt; Item -\u0026gt; one Number    Output actions. Actions can be inputs (initiated by a user) or outputs (initiated by the system). An input action can have output parameters as well as input parameters.\n  Determinism. I prefer all actions to be deterministic. This doesn’t actually prevent the system from making choices that aren’t controlled by the user; it just means that those choices must be exposed in action parameters. For example, an airline reservation system might assign a seat to a passenger with an action whose signature is\n assignSeat (p: Passenger, out s: Seat)   ","permalink":"https://essenceofsoftware.com/tutorials/concept-basics/apps-are-state-machines/","summary":"If user experience runs deeper than the user interface, we need a way to talk about an app that isn’t just visual, and that captures behavior in a more fundamental way.\nProgrammers think in terms of complicated things like objects, callbacks, streams, functionals, and so on. They’re essential for structuring code, but for behavior a much simpler model is effective.\nState machines That model is the state machine. You’ve probably come across state machines, either in a class about the theory of computation, or seeing diagrams like this:","title":"Apps are state machines"},{"content":"In the 1980s, there was a revolution in software. The Apple Macintosh came out (building on the invention of the WIMP interface at PARC), Don Norman wrote The Design of Everyday Things, and the first CHI conference was held.\nNow everyone knows how important user interface design is, and there’s no excuse for messing it up. You can find several collections of UI design heuristics (such as Nielsen’s) online, and many companies publish standards for how to use UI widgets consistently (here’s Google’s, for example).\nThe downside of all this success is that people sometimes forget that UI design is only part of software design. A good user interface is necessary for a good user experience but it’s not sufficient. Just as important—maybe more important—is the underlying functionality, defined by the concepts that the software provides.\nIn my book, I open with a story about Dropbox. Its UI design is state of the art, but people still get confused and end up deleting other people’s files. The reason, I explain, is that the underling conceptual model is confusing.\nTo see how UX is more than the UI, consider three widgets that let the user do a thumbs-up on something:\nFrom a UI perspective, these look pretty similar. In each case, you click on some kind of “up” button to signal that you like something.\nBut behind this apparent similarity in the UI, there are actually three completely different concepts, which a user must grasp to make sense of these buttons.\nIn the first, on the left, the arrow-up action is part of an Upvote concept in StackOverflow: clicking it says you approve of the answer (or the question). The accumulation of clicks gives a crowd-sourced measure of the credibility of items, affecting the order in which they appear.\nIn the second, the thumbs-up action is part of the Reaction concept of Slack, and is just a kind of minimal message sent back to the author of a post. It has no effect on the order in which posts appear.\nIn the third, the thumbs-up action is part of the Recommendation concept in Netflix, and is used when you liked a movie that you saw. Your approval isn’t shared with other users, and it doesn’t affect the rank of this particular movie. What it does is indicate that you want to see more movies similar to this one.\nThe design considerations in these three examples are all very different, and each has subtleties and problems of its own. One example: a friend told me that she saw a movie that she thought was really sexist, so she didn’t want to give it a thumbs up, but she liked the genre so she wondered if she should anyway.\n","permalink":"https://essenceofsoftware.com/tutorials/design-general/beyond-ui/","summary":"In the 1980s, there was a revolution in software. The Apple Macintosh came out (building on the invention of the WIMP interface at PARC), Don Norman wrote The Design of Everyday Things, and the first CHI conference was held.\nNow everyone knows how important user interface design is, and there’s no excuse for messing it up. You can find several collections of UI design heuristics (such as Nielsen’s) online, and many companies publish standards for how to use UI widgets consistently (here’s Google’s, for example).","title":"Beyond the user interface"},{"content":"Defining design What\u0026rsquo;s a good working definition of the word design and how it differs from engineering? For those of us who care about design, this is an important question, because it helps explain what we do, and why it matters.\nHerb Simon said “To design is to devise courses of action aimed at changing existing situations into preferred ones.” This definition nicely highlights the design aspect of Simon’s own focus on decision making in organizations. But it’s too broad to help us understand what “software design” might be.\nKapor’s definition of design For that, I turn to Mitchell Kapor who defined design like this:\nIt’s where you stand with a foot in two worlds—the world of technology and the world of people and human purposes—and you try to bring the two together.\nKapor gives building design as an example. It’s the architect who designs the building and shapes the experience of its occupants. The engineer makes sure the building won’t corrode or sway in the wind, concerns that are critical but don’t require an understanding of people.\nIn just the same way, software development involves two very different kinds of activity: designing the functionality that shapes the user’s experience and engineering the system to support it.\nDesign is not just visual Just because software design involves people doesn’t mean that it’s only about the user interface (or more narrowly its visual appearance), or that it’s mostly about psychology and how people feel.\nThe focus of software design is devising and structuring behavior. Doing this well requires deep technical understanding. Just as the architect of a building has to understand not only how people experience spaces, but also what kinds of spaces can be built, so a software designer has to understand how people experience functionality and what kinds of functionality software can support.\nThe design/engineering spectrum You can sometimes do without an engineer (creating a poster or a teacup, for example) and sometimes without a designer (building a memory allocator or an integrated circuit).\nBut for most artifacts, including software, design and engineering are needed in equal measure.\nAnd sometimes one or other is needed when you might not expect it. The “screwpull” wine opener is not just a design product; it relies on the engineering of a Teflon coating that is slippery enough for the spiral not to get stuck in the cork.\nYou might think home routers and wireless access points would use designers only for making pretty boxes. But setting up a wireless network turned out to be more complicated and error-prone than most engineers imagined, and devices like Amazon’s Eero and Google’s Nest are distinguished from their competitors not by their bandwidth but by their ease of setup.\nWhether design or engineering matters more may depend on whether a technology already exists, so it changes over time. Marconi’s first radio was an engineering achievement, but Dieter Rams’s radio was a design product.\nWhere design differs Because design, unlike engineering, focuses on the meeting point between people and products, some big differences in practice emerge:\n Misfits. In engineering, the context of usage is more clearly understood. In design, the context invariably brings surprises, and failures are usually not because specifications aren’t met but because the specifications themselves were wrong. See Misfits. Role of specs. In engineering, the problem statement is a specification. In design, the problem is harder to characterize and finding specs of desirable behavior is the output, not the input of the design process. Qualitative vs. quantitative. In engineering, criteria can often be expressed numerically: a storage device has capacity, latency, bandwidth etc. In design, the criteria are usually more nebulous, if known at all.  Nevertheless, design and engineering activities have much in common. Perhaps most importantly (and often neglected) is the role of patterns and prior knowledge. New creations never come out of thin air, but are always adaptations and extensions of earlier ones.\n","permalink":"https://essenceofsoftware.com/tutorials/design-general/design-vs-engineering/","summary":"Defining design What\u0026rsquo;s a good working definition of the word design and how it differs from engineering? For those of us who care about design, this is an important question, because it helps explain what we do, and why it matters.\nHerb Simon said “To design is to devise courses of action aimed at changing existing situations into preferred ones.” This definition nicely highlights the design aspect of Simon’s own focus on decision making in organizations.","title":"Design vs. engineering"},{"content":"What is a design problem? What exactly is a design problem? And why are design problems often hard to solve?\nThe most compelling answer to this question, in my view, comes from Christopher Alexander in his influential book Notes on the Synthesis of Form (1964).\nMost of the book is about a way to structure goals into a tree, by noting alignments and conflicts between them, and grouping them to minimize conflicts across groups. This idea is very similar to Herb Simon’s notion of nearly decomposable systems, which was described in his “Architecture of Complexity” paper (1962) two years before.\nForm, context, ensemble and fit For me, however, the most interesting and valuable part of the book is the framework laid out at the very beginning on the essence of the design problem.\nDesign, Alexander explains, is the creation of a form within a context. Together these make an ensemble. The designer’s task is to ensure that the form fits the context within the bounds of the ensemble as a whole. A cork, for example, is a form that has to fit in the context of a wine bottle; together the cork and bottle make an ensemble.\nA rich framing This framing is richer and more subtle than it first appears to be:\n Choice of ensemble. Factors beyond the ensemble are not considered, so the choice of the ensemble places implicit bounds on the fitness criterion. If the ensemble for the cork design is expanded to include the wine cellar, the designer might need to consider the propensity of the cork to rot or dry out in different conditions. If expanded even further to include the trees from which the material of the cork is harvested, ecological considerations may arise, and suggest a different material. Choice of boundary between context and form. Even if the ensemble is fixed, the boundary between form and context is not. Suppose the ensemble for the cork design comprises the wine and its containers, the producers and the consumers, and fitness includes not only maintaining the freshness of the wine but also cost. In this case, a designer might propose switching from glass bottles to aluminum cans, identifying the context not as the glass bottle into which the cork is inserted but as the conditions of production, transportation and usage of the container. Simple fitness criteria. In simple cases, fitness can be reduced to simple criteria. Alexander gives an example of a metal face fitting against the surface of a standard steel block, which is (for all practical purposes) perfectly smooth. In this case, fitness amounts simply to whether or not the surface of the face is level enough; it can be tested by inking it and noting marks on the high spots; and it can judged without testing in context by specifying the permitted variance and measuring it. This kind of situation is more common in engineering than in the design of artifacts for human use. Unknowable fitness criteria. In more complicated cases, the criteria for fitness are so numerous that they cannot even be articulated. Worse, some criteria cannot even be predicted. The ring/silent switch on the iPhone X turned out for many users (including me) to be a hair puller. For some reason, the gap between the switch and the bezel traps hairs which then get yanked out when the phone is moved away from your head. Needless to say, users were not delighted by this feature and Apple reportedly was willing to replace their phones. If one were writing a list of requirements for a ring/silent switch, it seems unlikely that “don’t pull hair out” would be included.  Misfits The implications for software design, and design more generally, are far reaching:\n Completeness in requirements. The idea that requirements should be “complete” is rendered absurd, since the list of fitness criteria is infinite and unknowable. Misfits. The best we can do, Alexander asserts, is identify the most likely misfits: ways in which form and context and likely to not fit together. In designing a file system, for example, we might identify files getting accidentally deleted as a critical misfit: this is what motivates the Trash concept (and indicts the design of the Unix command line*). Being concrete, negative scenarios, misfits are explicit and tangible, so they’re easy to explain and understand. Experiment. The only completely reliable way to identify misfits is to try the form in the context and see what happens. In practice, however, misfits may take time to emerge, and may have already caused unacceptable damage before they are detected. Prototyping lets you test your design with lower risk and lower cost, but the context of the prototype may not match the real context well enough to catch even serious misfits (especially those with rare but disastrous consequences). Experience. Most misfits are identified not through experiments but from experience. If you’re designing an app for selling event tickets, for example, you would mitigate the risk of scalping; if you’re designing a backup utility, you’d want to defend against ransomware attacks. Neither of these misfits is predictable in the abstract, but failing to consider them, given all the experience we have building such systems, would be unforgivable. Patterns. Where does such knowledge come from if the designer lacks the right experience? This is what patterns offer: a way to record our accumulated experience about particular design problems and their solutions. Patterns not only codify designs that have worked well in practice. They can also highlight common misfits and their mitigations. In a catalog of concept patterns, the entry for Upvote would mention the problem of duplicate votes, and ways to prevent them (such as using cookies or IP addresses).  * Just consider what happens if instead of typing rm *.o you fail to hold down the shift key and type rm *\u0026gt;o instead.\n","permalink":"https://essenceofsoftware.com/tutorials/design-general/misfits/","summary":"What is a design problem? What exactly is a design problem? And why are design problems often hard to solve?\nThe most compelling answer to this question, in my view, comes from Christopher Alexander in his influential book Notes on the Synthesis of Form (1964).\nMost of the book is about a way to structure goals into a tree, by noting alignments and conflicts between them, and grouping them to minimize conflicts across groups.","title":"Form, context \u0026 misfits"},{"content":"Seven criteria What makes a design fit for purpose depends—surprise!—on the purpose. But generic criteria are helpful for two reasons. First, they give you some basis for evaluation, however crude. Second, they can be used as a checklist to suggest more specific ones.\nA software product should be:\n Efficient: letting users accomplish their goals with no more steps or effort than needed; Flexible: supporting not just one fixed and narrow goal, but a range of goals that users are likely to have; Responsive: responding to requests from the user in a timely way; Understandable: behaving predictably, offering options and producing outcomes that make sense to users; Robust: tolerant of errors made by the user and other common perturbations of context, such as failures of other systems or agents to perform their expected roles; Secure: resistant to malicious attacks, including social engineering attacks that induce the user to perform unintended actions. Just: allocating benefits amongst different groups of users and stakeholders in a fair way.  Non-criteria Some criteria I have intentionally omitted from this list:\n Simple: Simplicity is about the design itself, rather than the user’s experience of it, and it impacts all of the criteria (most notably understandability). Learnable: How easy it is to learn to use a product is part of how understandable it is. A well designed product not only conveys its states and actions for the user’s immediate understanding, but also teaches the user, helping build a mental model over time. The “product,” of course, must be broadly construed to include help features and training materials. Consistent: Some qualities are not ends in themselves, but means to achieving fitness, so are heuristics rather than criteria. Maintainable: Many qualities matter for developers but not for users (or at least, only indirectly); these are engineering rather than design criteria. Minimalist: Some writers advocate minimalism as a universal requirement of good design. It’s an attractive and compelling position, but it reflects a preference that is cultural and personal rather than universal. Many designers in the past (such as John Ruskin and Louis Sullivan) have argued that ornament and decoration are not surface treatments that detract from a design but are integral to it. Perhaps the pendulum will swing back again, and our affection for grey interfaces with text in Helvetica Light will wane.  The design space If we imagine each criterion has having a value between zero and one, then each design sits at a point in a 7-dimensional space, and we can compare designs with respect to their positions.\nComparisons are most instructive for designs that address the same problem: two email clients, for example, or two word processors.\nComparisons between designs that address different problems often reflect more on the problems than on the designs. Adobe Photoshop, for example, is less understandable than Adobe Lightroom, in that the cognitive burden of becoming familiar with Photoshop is greater. This is as expected, since Lightroom (roughly speaking) only lets you adjust the values of the pixels in a single photo, whereas Photoshop lets you combine and rearrange pixels from different photos.\nTradeoffs The designs that solve a given problem are not usually distributed uniformly over the design space. Instead, they sit on a plane so that increasing the value of one criterion means decreasing another.\nA design that is more flexible and efficient will usually be less understandable and less robust. Take, for example, the two file managers that are available in MacOS: the Macintosh Finder (comprising the windows and icons, and manipulated mainly by clicking and dragging), and the Unix command line (accessible through the Terminal application, which takes textual commands).\nThe Unix design is more flexible (you can put a file in two folders, for example) and also more efficient (you can more easily move many files at once, for example). But it is at the same time less understandable. Even the most basic command, mv, performs two distinct actions (moving and renaming files and folders) and can behave differently when a trailing slash is added, contrary to the assumptions of many users. It is also less robust: if you inadvertently mv one file onto another (by typing mv a b, intending to rename a to b, unaware that b already exists), the second will be irretrievably lost.\nSometimes, a higher value in one criterion can mitigate a lower value in another. For example, greater understandability can make up for some loss of robustness. In the Backblaze backup utility, the message “Files backed up as of 1:00pm” gives the user the impression that file contents generated prior to 1:00pm will be safe. In fact, the backup is not truly continuous, but instead periodically creates a list of modified files and then uploads them. Files changed after the creation of the list are not uploaded. This evident lack of robustness would be mitigated by a clearer message that helped users understand the “blind spot” in the backup process.\nNotes  The generalization of error tolerance to robustness is inspired by Eunsuk Kang’s recent work. Justness is a big topic, which I address in my teaching through Batya Friedman’s Value Sensitive Design. These criteria expand on a list initially drawn up by Rob Miller for the MIT user interface design class 6.831.  ","permalink":"https://essenceofsoftware.com/tutorials/design-general/fitness-criteria/","summary":"Seven criteria What makes a design fit for purpose depends—surprise!—on the purpose. But generic criteria are helpful for two reasons. First, they give you some basis for evaluation, however crude. Second, they can be used as a checklist to suggest more specific ones.\nA software product should be:\n Efficient: letting users accomplish their goals with no more steps or effort than needed; Flexible: supporting not just one fixed and narrow goal, but a range of goals that users are likely to have; Responsive: responding to requests from the user in a timely way; Understandable: behaving predictably, offering options and producing outcomes that make sense to users; Robust: tolerant of errors made by the user and other common perturbations of context, such as failures of other systems or agents to perform their expected roles; Secure: resistant to malicious attacks, including social engineering attacks that induce the user to perform unintended actions.","title":"Generic fitness criteria"},{"content":"Think about your favorite product, whether it’s a photo-editing app or a toaster, and ask yourself: how did it get to be so good?\nWith all the hype in the design world about creativity and brainstorming, it’s easy to imagine that great designs simply appear, out of the blue. Someone conjures up a new idea, and it just needs to be translated from sketch to product. Maybe many details need to be added, but the quality of the design was there at the start—like a tiny seed that grows spontaneously into a magnificent tree.\nA much better model of design is described by George Saunders in his book A Swim in the Pond in the Rain. Saunders is talking about writing, but his ideas apply equally well to designing.\nSaunders starts by writing down a bunch of sentences. Then he prints out the draft, and painstakingly marks it up, imagining, as he reads along, a meter stuck on his forehead with a needle that swings from N (negative) to P (positive) as he reacts to it intuitively. Then he fixes up the draft with his corrections, and starts the whole cycle over again.\nIn this way, the tone and quality of the writing—and the voice of the author—emerge gradually over time. By the end of the process, the writer has something in front of her that she could never have imagined at the start. Even the writer’s persona, as reflected in the piece, grows and adapts over time, until it reaches a state that may even be an improvement on the reality!\nMost radically, this process makes the starting point less critical. As Saunders explains:\nThe beauty of this method is that it doesn’t really matter what you start with or how the initial idea gets generated. What makes you you, as a writer, is what you do to any old text, by way of this iterative method. This method overturn the tyranny of the first draft. Who cares if the first draft is good? It doesn’t need to be good, it just needs to be, so you can revise it. You don’t need an idea to start a story. You just need a sentence.\nApplying this model to design has profound and encouraging implications:\n When creativity happens. The creative work of design isn’t just at the start during some kind of “ideation” phase. On the contrary, most of it resides in the iterative adjustment of the design, in which the design is critiqued and adjusted in response to a stream of new ideas. Where quality resides. What makes a design great is almost never a single novelty arising from a momentary insight, but rather an elegant alignment and uniformity that results from an accumulation of many small steps. Perhaps this is Christopher Alexander’s “quality without a name.” The journey. You might worry that a process of design revision could leave you stuck in a local minimum in the design space, like someone digging a hole for treasure in a field who just digs deeper and deeper when they can’t find it. But if you take the revision process seriously, and view it as a creative journey, then every step offers an opportunity for a small change of direction, and you are likely to end up far from where you started.  What about the practical consequences?\n Embrace iteration. If you want great design, you’ll need to embrace iteration. Sometimes this will mean postponing implementation as much as possible, so that you have the time to evolve your design before committing to code. Or if you must implement early, consider implementing a simpler design with known flaws rather than a complicated design whose features may turn out to be unnecessary in practice. You might even place a doorbell in the jungle. Don’t obsess about ideation. Don’t invest too much in ideation activities. Save most of your effort (and your best designers) for revising your design. And don’t reject initial ideas because they’re not novel enough. On the contrary, it’s often best to start with a familiar concept that has been tried and tested, and whose limitations are well understood, and then morph it if it fails to solve the problem. Be obsessive. Every small flaw you detect when reviewing a design, or that gets exposed from the experience of users, is not only an opportunity for a small improvement. If you think about it deeply, it can be a window into a new way of viewing your design, and a chance to take a step in a new direction.  ","permalink":"https://essenceofsoftware.com/tutorials/design-general/great-design/","summary":"Think about your favorite product, whether it’s a photo-editing app or a toaster, and ask yourself: how did it get to be so good?\nWith all the hype in the design world about creativity and brainstorming, it’s easy to imagine that great designs simply appear, out of the blue. Someone conjures up a new idea, and it just needs to be translated from sketch to product. Maybe many details need to be added, but the quality of the design was there at the start—like a tiny seed that grows spontaneously into a magnificent tree.","title":"How great design happens"},{"content":"When you’re diagnosing a usability snag, or coming up with a new design idea, it’s helpful to know what level you’re working at.\nOver the years, designers and researchers have defined various levels, reflecting their view of design and what they emphasize.\nI find the following scheme most helpful:\n Physical. If you want to think of levels as low and high, this one is at the bottom. It’s the level of design in which you’re concerned about the physical (and physiological) qualities of human users. So it might involve physical things (like picking colors), but it includes less tangible aspects too (such as how long an action can take before you need to show a progress bar). To do this kind of design, you need to know a bit about human anatomy and physiology. For example, Fitts’s Law tells you how long it takes to move a pointing device to its target; perceptual fusion tells you that a delay of more than 10ms will be perceptible; and the fact that 1 in 12 males is red-green colorblind says you’d better not rely on those colors for important distinctions. Linguistic. This level involves design around language, and how you can use icons and words to convey information to users. Unlike the physical level, this level is culturally dependent: a white circle with a red border means no entry to Europeans, but not to Americans. One of the most important design heuristics is to use linguistic cues consistently within your app and across apps. Conceptual. This level is about the semantics of an app: its behavior, given by the actions you can perform and the state the actions read and write, and the meaning and implications of those actions and state.  Here’s a picture illustrating these levels. The illustration for the linguistic level is a British road sign affectionately known as “man having trouble opening umbrella.”\nBeyond the conceptual, there’s another level that is significant but less often considered explicitly by designers. We might call it the social level, and its about the impacts that your app has on society. In the design of a social media app, for example, you’d want to make sure you don’t encourage addiction and damage the self-esteem of teenagers.\n","permalink":"https://essenceofsoftware.com/tutorials/design-general/levels-of-design/","summary":"When you’re diagnosing a usability snag, or coming up with a new design idea, it’s helpful to know what level you’re working at.\nOver the years, designers and researchers have defined various levels, reflecting their view of design and what they emphasize.\nI find the following scheme most helpful:\n Physical. If you want to think of levels as low and high, this one is at the bottom. It’s the level of design in which you’re concerned about the physical (and physiological) qualities of human users.","title":"Levels of design"},{"content":"A compelling way to explain how something works is to tell a story. Not any story, but a kind of defining story that shows, through a typical scenario, why the thing is useful and fulfills its purpose.\nThe Minuteman Library Network, for example, offers a wonderful service. If I request a book, then when it becomes available at my local library, I get an email notifying me that it’s ready to be picked up.\nNote the form this scenario takes: if you perform some actions, then some result occurs that fulfills a useful purpose. Many kinds of mechanism can be described in this way:\n If you make social security payments every month while you work, then you will receive a basic income from the government after you retire. If you insert a slice of bread into the toaster and press down the lever, then a few minutes later the lever will pop up and your bread will be toast. If you become someone’s friend and they then publish an item, you will be able to view it.  One reason that scenarios are so compelling is that we observe them all around us. Using an elevator is actually quite complicated, but we learned how to do it by watching other people. Many people haven’t yet learned how to use Schindler’s PORT elevator, so the story needs to be told explicitly:\n Enter the floor you want to go to on the keypad and note the elevator number that is subsequently displayed; now wait for the elevator with that number, and it will stop at your floor.  Each concept has one or more such stories that explain how to use the concept, and show that the concept fulfills its purpose. I call such a story an operational principle (OP), a term introduced by the chemist philosopher Michael Polanyi and made known to the software world by my father Michael Jackson.\nUse cases, OPs and snooze alarms Because an OP is a scenario, you might confuse it with a use case. But these are very different things. Use cases are for specifying the requirements of a software system, so even a simple system will have a large number of use cases, covering not only ones in which the user succeeds but also those in which the user fails.\nIn contrast, the OPs of a concept aren’t intended to specify it fully, so they can be few and brief. The OPs characterize a concept’s essential behavior, explaining how it works and fulfills its intended purpose. All details that are not fundamental to the design are left unspecified.\nConsider a digital snooze alarm clock. The first OP is this:\n If you set the alarm for a given time, and turn the alarm on, then when that time comes around, the alarm will ring (for some fixed time or until you turn it off).  We can add a second OP to explain the snooze function:\n When the alarm starts ringing, you can press the snooze button, and it will stop ringing and start ringing again after some fixed time, and you can then turn it off.  These OPs tell you enough to use the alarm clock, and they justify its design. But they barely begin to answer all the questions you might have about the details of its behavior. What happens if you press the snooze button again? If you turn the alarm off after pressing the snooze button but before the alarm rings again?\nOf course the designer will have to answer all these questions in a reasonable way, but they’re not the essence of the design. That doesn’t mean that we won’t come across additional scenarios that matter enough to be recorded as OPs. This one, for example:\n If you set the alarm for a given time, do any sequence of actions except for setting the time, and then turn the alarm on, then it will ring when the given time comes around.  This ensures that when you set the alarm time it “sticks” from day to day, and snoozing (in particular) won’t change it. It’s not the only possible design. You could imagine a clock that resets the alarm time to 8:05am if it was set previously to 8:00am and then snoozed.\nSpecifying full behavior So if the OP doesn’t fully specify the behavior of a concept, how do you do that? I’ll cover that in detail in another post, but here’s the idea. In short, you define the state of the concept and then define the effect of each action on the state (just like writing high-level code):\nstate alarmTime, ringTime, now: Time on: Bool ringing: Bool = on \u0026amp;\u0026amp; 0 \u0026lt; (ringTime - now) \u0026lt; RINGT actions\tsetAlarmTime (t: Time) alarmTime := t tick (t: Time) now := t alarmOn () on := true; ringTime := alarmTime alarmOff () on := false; snooze () if ringing ringTime := ringTime + SNOOZET  Notes. The alarm is defined to ring for a time RINGT after it goes off and to snooze for a time SNOOZET. The passage of time is modeled explicitly by an action that updates the current time.\nExercises for the reader. (1) How must SNOOZET be related to RINGT, and why? (2) What happens if you set the alarm time to just before the current time?\nIf what you’re trying to do is fully specify a concept’s behavior, this kind of state machine model is the way to go. It’s much more succinct than scenarios (and so better than use cases, in my view, in this role).\nBut OPs offer something else. In a technical sense, you can infer all scenarios from the state machine, but that doesn’t mean you can make sense of them. To understand the snooze function you need to know how it’s typically used: the alarm rings, you press snooze and then it rings again a bit later.\nSo the OP helps by distinguishing the archetypal scenario from other scenarios that are equally plausible (in terms of the state machine) but play no role in explaining the concept’s purpose. For example, you can let the alarm ring until just before the moment at which it switches off and press snooze then. This scenario is as valid (to the state machine) as our first OP (in which you press snooze when it starts ringing) but it’s not helpful in understanding why the snooze function was invented.\nHow many OPs? A simple concept may have just one OP. Here’s an example of a concept whose OP is almost too trivial to explain:\n Comment. If you add a comment to an item, then the comment will appear in the list of comments displayed with it.  Some concepts, though, need two or more OPs to explain their essential functionality:\n Trash. (1) If you delete a file, you can then restore it by moving it out of the trash. (2) If you delete a file and then empty the trash, the file is gone forever and its storage space can be reused. Password. (1) If you register with a user name and password, and then you login with that same user name and password, you will be authenticated as the user who register (that is, able to act in their name). (2) If you register with a username and password, and then you login with that same username but a different password, you will not be authenticated. Personal access token (PAT). (1) If you create an access token for a resource and pass it to another user, then that user can enter the token string and obtain access. (2) If you create an access token, pass it to another user, and then revoke it, the other user will not be able to access the resource with it.  It’s not unusual for a more elaborate OP to be the one that actually motivates the concept design. For the PAT concept, it’s the revocation that’s the essence: without it, a simple password would do.\nPurposes, not user goals The design of a concept is driven by some purpose that the concept fulfills. In some cases, this purpose is aligned with a simple user goal. The purpose of the TextMessage concept is to convey messages between users; a user following the OP (if you send a message to another user, then they will receive it) has the simple goal of conveying a single message.\nIn general, however, user goals are not so easily aligned with purposes. A user always has some motivation to perform some action or sequence of actions, but the motivation is often inchoate and not worth dwelling on in the design process.\nThe purpose of the Password concept, for example, is to authenticate users. Neither the user who successfully logs in nor the user who fails has a goal that fully matches this purpose, whose essence is to distinguish the two cases.\nOne of the risks of focusing on user goals is that it becomes tempting to articulate shorter scenarios that have no relationship to the purpose at all. There’s no point writing a scenario for registering a password, for example. It provides no value in itself to the user, and matters only in the context of the OP in which it’s followed by a successful (or unsuccessful) login.\nOPs with multiple users Another reason an OP might have no user goal is that the purpose involves collaboration of multiple users. The purpose of Upvote is to let users rank items by their popularity. When you as a user give a thumbs-up to an item, you’re not fulfilling a goal worth articulating, but simply contributing to a larger communal purpose. The OP for Upvote must include a upvotes by multiple users on multiple items, to illustrate the key idea that the ranking of items depends on the number of upvotes they receive.\nThe danger of “secondary” goals One final problem with goals: they encourage you to think that some goals are primary and others secondary. But it may well be the supposedly secondary goal that motivates the design of the concept.\nTake the ShoppingCart concept, for example. You might be tempted to label as primary the OP in which a user adds an item and checks out immediately (thus buying the item in the most efficient way), and label as secondary the OPs in which the user adds multiple items, or adds and then removes items.\nBut just as the purpose of the Trash concept is not deletion but undeletion, which is illustrated by the OP in which an item is deleted and then restored, so the purpose of ShoppingCart is to allow items to be selected for purchase without commitment. If it were merely to make it easy to buy items, a different, simpler concept would suffice (such as Amazon’s one-click BuyNow).\nWriting good OPs OPs offer a lightweight and provocative way to explore a new design or record an existing one. Here are some tips on writing good OPs.\n Purpose. Have the concept purpose in mind: that the purpose of Trash is undeletion (and not deletion), or that the purpose of Password is authentication (and not creating accounts or anything like that). Full history. Remember to include a long enough history of actions to demonstrate the purpose. Registering a password is useless by itself; it only becomes interesting when you log in later. One concept. If your OP looks complicated, you may be mixing the OPs of distinct concepts. A scenario in which a user logs in, views a friend’s post and then comments on it involves at least three concepts (Password, Friend, Comment). Actions not buttons. Write the OP in terms of the actions and states that form the concept (and the user’s mental model), not the realization of the concept in the user interface. So keep out details of UI buttons and views, and avoid especially breaking a single action (such as a login attempt) into multiple steps (enter name, enter password, press submit).  ","permalink":"https://essenceofsoftware.com/tutorials/concept-basics/operational-principle/","summary":"A compelling way to explain how something works is to tell a story. Not any story, but a kind of defining story that shows, through a typical scenario, why the thing is useful and fulfills its purpose.\nThe Minuteman Library Network, for example, offers a wonderful service. If I request a book, then when it becomes available at my local library, I get an email notifying me that it’s ready to be picked up.","title":"Operational Principle"},{"content":"Most of us* believe that simplicity is the key to design. I’m a sucker for the best quotes about it. Here are some of my favorites. First, Tony Hoare in his Turing Award lecture lamenting the complexity of Algol-68:\nI conclude that there are two ways of constructing a software design: One way is to make it so simple that there are obviously no deficiencies and the other way is to make it so complicated that there are no obvious deficiencies.\nand on PL-1:\nAt first I hoped that such a technically unsound project would collapse but I soon realized it was doomed to success. Almost anything in software can be implemented, sold, and even used given enough determination. There is nothing a mere scientist can say that will stand against the flood of a hundred million dollars. But there is one quality that cannot be purchased in this way—and that is reliability. The price of reliability is the pursuit of the utmost simplicity. It is a price which the very rich find most hard to pay.\nNot just reliability—usability too. Here’s Edsger Dijsktra in a similar vein:\nThe opportunity for simplification is very encouraging, because in all examples that come to mind the simple and elegant systems tend to be easier and faster to design and get right, more efficient in execution, and much more reliable than the more contrived contraptions that have to be debugged into some degree of acceptability.\nBut perhaps best of all, and most relevant to software design, is the principle known as Gall’s Law:\nA complex system that works is invariably found to have evolved from a simple system that worked. A complex system designed from scratch never works and cannot be patched up to make it work. You have to start over with a working simple system.\n(I learned about Gall’s Law from Gordon Brander’s pattern collection.)\nGall’s formulation is particularly good because it doesn’t deny that complexity is inevitable in all real systems. It just reminds us that having a complicated problem is no excuse for designing a complicated solution.\n*Well, not all. I once visited Charles Simonyi at Microsoft and asked him, rather cheekily, if the length of the Windows manuals on his shelf, which extended all the way from one side to another, might be a symptom of a design that wasn’t simple enough. His response? “Simplicity is crap.”\n","permalink":"https://essenceofsoftware.com/tutorials/design-general/simplicity/","summary":"Most of us* believe that simplicity is the key to design. I’m a sucker for the best quotes about it. Here are some of my favorites. First, Tony Hoare in his Turing Award lecture lamenting the complexity of Algol-68:\nI conclude that there are two ways of constructing a software design: One way is to make it so simple that there are obviously no deficiencies and the other way is to make it so complicated that there are no obvious deficiencies.","title":"Simplicity"},{"content":"In an old interview, unfortunately no longer online, Jony Ive explained how his team at Apple had designed the MacBook\u0026rsquo;s rounded corners. \u0026ldquo;I suppose that\u0026rsquo;s pretty obsessive, isn\u0026rsquo;t it?\u0026rdquo; he ended, with a self-deprecating smile.\nIt struck me as a perfect metaphor for software design: that so often the real work is in the smoothing of rough edges. Each small protrusion and snag may seem inconsequential by itself, but in aggregate they create a constant stream of irritation and confusion for the user. Focusing on them may seem obsessive, but the result can be dramatic. As the Eames told us, the details are not the details: they are the design.\nConcept design offers a new way to control irregularities, the rough edges of software. In this post, using Zoom as an example, I\u0026rsquo;ll explain some simple tactics for identifying and then eliminating them.\nZoom\u0026rsquo;s Reaction Concept When analyzing an existing application, its concepts may not be readily apparent. In a well-designed app, the concepts will be mapped directly to user interface elements, but this is not always so (especially for subtle concepts). Nevertheless, when evaluating an app, it makes sense to start by assuming that the key concepts are aligned with the primary features as they present themselves to users.\nSo we\u0026rsquo;ll assume for now that the prominent button labeled Reactions corresponds to a concept, and we\u0026rsquo;ll treat it as such for now.\nNotice that there are three rows of buttons: (a) the top row, comprising emojis such as clapping, thumbs up, etc; (b) the middle row with yes and no buttons, left and right arrows, and a coffee cup; and (c) the bottom row with a single \u0026ldquo;raise hand\u0026rdquo; button.\nIrregularities in Reactions Clicking on any button, in any row, causes the corresponding icon to appear, as you\u0026rsquo;d expect. It actually appears in multiple places in the user interface, most prominently in the top-left-hand corner of your box in the meeting grid.\nWhat might not be so obvious is that the different buttons behave in slightly different ways.\nFirst, there\u0026rsquo;s a disappearing effect on some reactions but not others. Clicking on a button on the top row makes the emoji appear, but then disappear automatically after ten seconds; this doesn\u0026rsquo;t happen with the reactions on the other rows.\nSecond, some have an undo action. Clicking any button also produces a small icon above the Reactions dialog; for all but the emojis, these icons turn out to be buttons you can click to turn off the effect.\nThird, the buttons enforce some disjointness rules. The top row buttons operate as a radio button group; clicking any one replaces another (if it hasn\u0026rsquo;t yet disappeared). Likewise, the middle row is a group. Surprisingly, the Raise Hand button in the bottom row belongs to this group: if you\u0026rsquo;ve clicked the check mark, for example, clicking the Raise Hand button will make it go away.\nIn Search of Purposes Having identified these irregularities, our next step is to try and justify them—essentially reverse engineering the designer\u0026rsquo;s rationale.\nLet\u0026rsquo;s think about purposes. The Reactions concept as a whole has a simple purpose: to allow users to convey certain common feelings in a lightweight fashion. Digging more deeply, though, we can identify different sub purposes with each row.\nThe top row lets users convey emotions, presumably in reaction to something said or shown by someone else. For the middle row, it\u0026rsquo;s hard to find a single subpurpose. The yes/no buttons are for responding to questions from the speaker; the arrow buttons are to suggest that the speaker slow down or speed up; and the coffee cup button indicates that the user is away from the meeting. The Raise Hand button signals a desire to speak.\nWith these more refined purposes, we can now consider the irregularities and see if they make sense.\nThe disjointness idea is plausible: for example, you wouldn\u0026rsquo;t want to tell a speaker to slow down and speed up at the same time. The automatic disappearance is reasonable, too: clapping, for example, is a momentary gesture and it might be annoying to have to turn it off.\nBut when we examine these more closely, we see that there are some problems. It makes sense that speed up and slow down are disjoint, and that laughing and crying are too. But why can\u0026rsquo;t you clap and send a heart at the same time? And why does stepping away make your yes/no response disappear? And raising your hand cancel your request that the speaker slow down or speed up?\nWe can summarize the irregularities we\u0026rsquo;ve found in two tables. First, a table of the features of each reaction type, with a check mark showing that a feature is present, and a red checkmark in parens showing that it is present but probably shouldn\u0026rsquo;t be:\n   Reaction Disappears Counted Cancel by host     Emojis ✔︎ (✔︎)    Yes/no  ✔︎ ✔︎   Slow/speed  ✔︎ ✔︎   Away  (✔︎) (✔︎)   Hand  (✔︎) ✔︎    (Counted refers to whether a count is displayed for the reaction in the participants panel; cancel by host refers to that panel\u0026rsquo;s \u0026ldquo;clear all feedback\u0026rdquo; action. Both are discussed later.)\nAnd a table showing disjointness between reaction types:\n   Reaction Emojis Yes/no Slow/speed Away Hand     Emojis ✔︎       Yes/no  ✔︎ (✔︎) (✔︎) (✔︎)   Slow/speed  (✔︎) ✔︎ (✔︎) (✔︎)   Away  (✔︎) (✔︎) ✔︎ (✔︎)   Hand  (✔︎) (✔︎) (✔︎) ✔︎    The large number of red marks in these tables suggests we have work to do!\nFixing Irregularities The complicated differences between reactions are no doubt intended to save the user trouble (so you don\u0026rsquo;t need to unclap your hands, for example, or turn off slow down when you want the speaker to speed up). But like any automation, they come at the expense of reduced flexibility.\nIn some cases, the flexibility is minor: being able to send more than one emoji at a time, for example. But in others, it\u0026rsquo;s more significant. I can\u0026rsquo;t imagine that any speaker really wants the yes/no responses to a question to disappear when participants raise their hands.\nThis suggests a concept design that lets the developer adjust the rules over time. Rather than hardwiring the fact that claps disappear but yes/no answers don\u0026rsquo;t, we could design the Reaction concept with an action makeDisappearing (reaction), which, when executed, causes a particular reaction to become a disappearing one. In a preamble in the code, a series of calls can then configure the reactions to be disappearing or not.\nA similar strategy can be applied to disjointness: an action addToGroup (reaction, group) might add a reaction to a radio button group with the effect that all reactions in the group are mutually disjoint.\nWith this richer concept in hand, it would be easy to fix the problems in Zoom. We can assign the yes and no reactions to one group, and the slow down and speed up reactions to another.\nNote also that a concept that has been parameterized in this way is properly generic. Our Reaction concept need know nothing about emoji or yes/no answers; it simply has a generic notion of reactions. Keeping a concept generic saves us from introducing domain-specific behaviors, and thinking about using the concept in other contexts helps us evaluate its plausibility.\n(It would be interesting to know if the design of Zoom already incorporates this more flexible concept, or if the programmers have instead hardwired a collection of behaviors—which might explain why what seem to be some undesirable cases have not been fixed. It also seems that these irregularities have changed between versions. When the disappearing behavior was introduced, it applied to the second row of reactions too, leading one frustrated teacher to recommend that you use the raise hand reaction for counting responses to a question instead!\nMore controversially, we could expose these configuring actions to users, letting each user decide what behavior they want: for example, whether they want to be allowed to display multiple emojis at once.\nAnother possibility is to simply eliminate the irregularities. We could design the Reaction concept with two distinct actions: toggleReaction (reaction), which turns a reaction on or off; and transientReaction (reaction), which shows a reaction for ten seconds or extends it for ten further seconds if it\u0026rsquo;s already showing. One could map these actions to the user interface in various ways: a double-click might be a toggleReaction and a single-click a transientReaction, for example.\nOf course, such a design introduces its own complications. I\u0026rsquo;m not recommending it, but just illustrating the range of possibilities.\nDoubling Down: Expanding Differences When you encounter an irregularity in a design, one response is to try and minimize it or even eliminate it. But the opposite may be plausible too: to actually expand the irregularity. If differences are justified by purposes, then distinct purposes may call for amplifying differences amongst the functions that fulfill them.\nHaving noticed that the reactions behave differently, we identified at least two different subpurposes: sending emotional reactions (clapping, smiley faces, etc) and providing feedback (slow down, speed up, etc). One difference between these is that reactions in the first class disappear automatically.\nRecognizing these distinct subpurposes, we might now wonder whether they suggest additional differences in behavior.\nFirst, we might consider differences of audience: perhaps feedback should be shown only to the speaker; a student in a class might not want to share with all the other students a request that the lecturer slow down (and might want to be anonymous to the lecturer too). And perhaps users would like to select the targets of their emojis, sending a heart to just one favored participant, say.\nSecond, noticing that the participant window shows counts for reactions:\nwe might decide to only count some kinds of reaction. Counting how many participants replied yes vs. no, or how many said speed up vs. slow down makes sense. But do we need a count of the number of participants who have sent hearts?\nThird, we might consider differences in interactions with other concepts. Perhaps emotional reactions should be included in the chat window, for example, the way they are in Slack:\nReaders familiar with concept design will detect a bad smell in this discussion. Expanding irregularities amongst reactions will make the overall Reaction concept more complicated and fragile. To keep it generic, we\u0026rsquo;ll now have to have classes of reactions that are counted and classes that are not; and classes that can have targets of particular users; and classes of reactions that are reported in the chat.\nThese irregularities have arisen because a single concept is now serving multiple purposes—and those purposes are to some degree in conflict with each other. This is what I call overloading, and it suggests that we should consider splitting Reaction into multiple concepts.\nEven Larger Differences: Concept Splitting Once the possibility of concept splitting comes up, we start to see opportunities for even larger differences between the reactions (and we\u0026rsquo;ll be reaching the point where it will no longer make sense to even talk of them as \u0026ldquo;reactions\u0026rdquo; as if they were a uniform set with a single purpose).\nThe Raise Hand function, for example, seems to be in a different category from the others, because of the role it plays in negotiating who\u0026rsquo;s speaking. People often forget to lower their hands, making us wonder if a concept is called for that manages the queue of requests to speak, letting a moderator select the next speaker and automatically lower their hand.\nThe emoji reactions might be absorbed in a more conventional reaction concept associated with the chat window: sending emojis could still be easily accessible via buttons on the toolbar, but these might be shortcuts for emoji messages that are similar to other messages in a chat, but just shorter.\nWe\u0026rsquo;ve gone full circle in a sense, here: we accepted the irregularity of emoji reactions (as distinct from yes/no, for example), and even embraced it. Now we\u0026rsquo;re proposing moving the emoji functionality out of the Reaction concept into another concept. But recognizing that the Chat concept might be the right place for it, we\u0026rsquo;re ending up having actually eliminated the irregularity! We might retain the distinction that emojis, unlike regular text messages, show in a user\u0026rsquo;s box in the meeting grid. Even this might be worth reconsidering, however. Maybe chat messages could be displayed there too; I could imagine asking a small class to post a brief response to a question, and preferring to see those responses next to the faces of my students rather than in the chat window.\nLikewise, the \u0026ldquo;I\u0026rsquo;m away\u0026rdquo; button suggests a concept in its own right. It brings to mind the concept of Presence in social media apps such as Slack, in which a user can indicate their availability and readiness to participate.\nAs to the yes/no, slow down/speed up buttons: they too suggest a separate Feedback concept. The Feedback concept is what you might call a fledgling concept in Zoom. It\u0026rsquo;s not quite there, but there are hints in various places that the developers have such a concept in mind. There is a \u0026ldquo;clear all feedback\u0026rdquo; action in the Participants window; unfortunately, the word \u0026ldquo;feedback\u0026rdquo; does not appear in the Reaction window so it will be unclear to most users that it refers to all but the first row of reactions. And it\u0026rsquo;s strange that \u0026ldquo;I\u0026rsquo;m away\u0026rdquo; and a raised hand are treated as feedback, so when this action is executed, those flags disappear too.\nOne might also wonder whether the yes/no buttons are intended to provide a kind of ad hoc poll. If so, perhaps they should be integrated into Zoom\u0026rsquo;s Poll concept. This concept is rather heavyweight: you have to create questions in advance, give a title to the poll as a whole, and only multiple-choice (and not yes/no) questions are supported.\nA User Interface Mockup Our concept analysis of the Reaction concept has led us to a realization that there are actually multiple concepts behind this one dialog. Ideally, concepts are mapped directly to the user interface. Here\u0026rsquo;s a mockup of how things might look, with tooltips showing all at once:\nThe raise-hand and coffee-cup reactions have been moved into a Presence concept (far left) with which the user indicates their participation (requesting to speak, speaking, watching/listening or away). The audio and video settings might be set implicitly: when you switch to speaking, for example, your audio is unmuted. This might address the common problem that users often start speaking without unmuting. Also, some (like me!) are anxious in a large meeting that they might have their audio on inadvertently, so having an explicit indicator that you\u0026rsquo;re not speaking may help. Less common settings (eg, speaking with video off, or speaking with video on and audio off for an ASL presenter) could be available in a submenu.\nThe emoji reactions have been moved into the Chat concept, which is now directly accessible on the toolbar. And the slow down/speed up reactions are now in a Feedback concept of their own, along with visible counts. These controls might appear only when a host activates them.\nOf course, this is all speculative, and this design undoubtedly has flaws yet to be discovered. My intent in showing this mockup is not to claim that it would necessarily work better than Zoom\u0026rsquo;s current arrangement, but simply to show the way in which concept analysis can drive user interface design.\nSummary of principles The approach I\u0026rsquo;ve described here is guided by a few basic principles:\n Irregularities, or differences between similar features, usually impose a cognitive burden, because there\u0026rsquo;s more to understand than when things behave the same way. Simplicity therefore suggests eliminating irregularities and a preference for uniformity. An irregularity may, however, serve a legitimate purpose, and its value may exceed the cost. So any evaluation of irregularities must make purposes explicit. For each irregularity, then, we must determine whether it is justified (and should be tolerated) or not (and should be eliminated). If justified, we should ask whether the irregularity is sufficient to support the purpose that motivates it, or should even be extended. A concept can accommodate a certain amount of irregularity in its design, but the irregularity can be organized in a systematic and generic way. Once purposes diverge significantly, it is better to split into multiple concepts for each of the variant forms of behavior, rather than attempting to contain them within a single concept. Paradoxically, this final extension of differences typically reduces irregularities, because each concept is now more regular. If the new concepts already exist in the app, or are familiar from other apps, the perceived gain in simplicity is even greater.  Summary of tactics The process I\u0026rsquo;ve outlined here is summarized in the diagram below:\nThe process may be executed as a routine design review, applied to each concept in turn. Alternatively, it may be prompted by a misfit that is observed (to use Christopher Alexander\u0026rsquo;s term). In my case, the misfit was the common experience of participants in meetings forgetting to lower their hands after they spoke, which led me to take a closer look at Zoom\u0026rsquo;s Reaction concept.\nOnce the relevant concepts have been identified, we look for irregularities. For each irregularity, we try to find either a justification (eg, that emoji, unlike raised hands, are transient gestures so it makes sense that they should disappear spontaneously), or a problematic scenario (for example, a lecturer losing track of yes/no answers because raised hands clear them). These lead to a classification of which irregularities should be retained and which should be eliminated.\nThe next phase involves a design intervention: refining the concept at hand (eg, defining configurable disjointness rules for reactions), splitting into multiple concepts (eg, factoring out the raised hand reaction into a Moderation concept), or merging some functionality into an existing concept (eg, moving emoji into Chat).\nThe outcome of the phase is a modified design. Hopefully it\u0026rsquo;s an improvement, but we might have introduced new problems, or failed to solve the initial misfit. Some evaluation is called for, whether by user studies, design review or some combination. As with any design process, some iteration is inevitable.\nHow Concepts Help The basic idea of identifying and eliminating irregularities is not specific to concept design. But concepts help in some key respects:\n The task of reviewing a design for irregularities is eased by considering one concept at a time. Concept design\u0026rsquo;s focus on motivating purposes helps us clarify which irregularities are justified and which are not. Concepts give modular boundaries within which to add new functionality (such as the addToGroup configuring action). Concepts help structure refactorings in which functionality is moved (eg, emojis becoming part of the Chat concept).  An Invitation I\u0026rsquo;m sure many of my readers have conducted analyses similar to the one I describe here. If you have one you can share, please post it in the concept forum. And as always, comments, criticisms and reactions (!) welcome.\nA Concept Integrity Violation You may wonder why I included parens around the red checkmarks in the tables. Winter Ferguson pointed out that those checkmarks appear uncolored on Android phones. Android automatically converts text characters to corresponding emoji, on which CSS colors are then ineffective. This is a nice example of a concept integrity violation and is a known problem.\n","permalink":"https://essenceofsoftware.com/posts/smooth-software/","summary":"Removing irregularities is perhaps the best way to achieve simplicity. This post explains some tactics for how to do it.","title":"Smooth Software"},{"content":"The secret of great design Watch great designers at work, or study their designs, and you may wonder: what\u0026rsquo;s their secret? Are they preternaturally inventive? Do they have better taste and judgment than the rest of us? Perhaps, but I don\u0026rsquo;t believe that this can account for the best designs. Based on my own experience studying design and designers (mostly but not exclusively for software), I\u0026rsquo;d attribute the success of great designers to two factors.\nFirst, they\u0026rsquo;ve done it before. Contrary to the picture of design implicit in the design thinking movement—in which extraordinary ideas emerge out of the blue, and each design problem is considered afresh—most designs are adaptations, extensions and compositions of design ideas that came before. A great designer is able to see the essence of a problem, find analogies to problems previously encountered, and rework old solutions.\nSecond, they refine their work. Nobody can solve a challenging problem in one step. What distinguishes great designers from mediocre ones isn\u0026rsquo;t that their first attempts are so much better, but that they critique their work ruthlessly, and keep polishing it until no more improvement seems possible. This observation is not unique to design; George Saunders says it\u0026rsquo;s the secret of great writing too (and perhaps it\u0026rsquo;s a general life strategy).\nImplications for software design Each of these has its implications. The first suggests we might codify a collection of reusable design ideas—both patterns (reusable solutions) and design moves (reusable tactics)—for software. Patterns have been very influential in software engineering (that is, in shaping implementation structures), and concept design is an attempt to find patterns in software design (that is, in shaping behavioral structures). Design moves have been discussed less but are no less important.\nThe second suggests that we need language, structures and design criteria for expressing and evaluating software designs, and that we need to engage in intensive critique of our designs. User testing is valuable, because you usually learn surprising things from people who approach your designs without your preconceptions. But like any form of testing, it doesn\u0026rsquo;t directly help you make a better product. Think about testing code: it can expose bugs (although rarely the subtle ones), but if you just fix each bug as you find it, you\u0026rsquo;re not going to end up with reliable and robust code. Whereas testing encourages you to focus on local details, and to fix problems with patches that can even reduce clarity and uniformity, critique focuses your attention on the essential and more structural aspects of a design and tends to lead to adjustments that produce better overall alignment and consistency.\nAlthough design thinking has done good things, raising awareness of design and encouraging people in all walks of life to see new opportunities for design, it has also tended—perhaps because of its emphasis on democratization of design—to undermine expertise and the value of critique. Natasha Jen, a Pentagram designer, pokes fun at design thinking for these flaws.\nConcept design moves Thinking about design moves, I came to realize that many of the case studies that I analyze in EOS involve one or more simple tactics. I\u0026rsquo;ve classified them into 3 pairs of design moves, each pair comprising a move and its dual. A design move isn\u0026rsquo;t a panacea; it trades off one quality of the design for another. If applied skillfully though, a single move can transform a design from good to great.\nI outline the design moves and give examples of their application in a paper that I\u0026rsquo;ll be presenting in a keynote at the NASA Formal Methods conference in May. (Also see slides on this topic from my recent talk at the Boston ACM/IEEE chapter.) Here, I\u0026rsquo;ll just give a taste of the moves.\n  Split/merge. Split breaks a concept into multiple smaller concepts; merge forms a composite concept from distinct ones. The tradeoff here is between simplicity and power: with more than one concept, the user has more control but things are also more complicated.\n  Unify/specialize. Unify takes a collection of concepts that are variants on a theme and unifies them in a single concept specialize breaks a single concept into more specialized variants. The tradeoff here is between generality and problem fit; when you unify, you end up with fewer and more general concepts, but they don\u0026rsquo;t fit the specific applications quite so well.\n  Tighten/loosen. Tighten increases the synchronization between concepts; loosen weakens it. The tradeoff here is between automation and flexibility. With tight synchronization, the user does less but also has fewer options.\n  A language of design: an example Design moves—and concepts—don\u0026rsquo;t guarantee that your designs will be good. But they give you a language for thinking about design, and a way to turn what might otherwise be an intimidating pile of seemingly arbitrary design options into a structured design space that can be navigated more systematically.\nRather than repeating examples from the paper, I\u0026rsquo;ll illustrate this idea with a design move that has yet to be applied. In EOS, I briefly discussed the problem of raised hands in Zoom. People in a meeting raise their (virtual) hands to request to talk, and when their turn comes, they unmute themselves but often forget to lower their hands again. The host, on later spotting the hand still raised, has to ask: is that from before, or a new request to speak?\nWhen I think about this problem, two design moves come to mind. One is the tighten move: we could synchronize the RaisedHand and Mute concepts so that (for example) when you unmute yourself your hand is automatically lowered. This would allow the two concepts to continue to be used mostly independently, but it would have the annoying consequence of lowering your hand (and losing your place in the queue) if you momentarily (and unintentionally) unmute yourself.\nAnother option is to apply the merge move to combine the RaisedHand and Mute concepts into a single concept, Moderation say, for moderated discussions. When the host switches to moderation mode, all non-hosts are muted by default and have to raise a hand to speak. The moderator chooses each speaker in turn, and their hand is lowered and they are simultaneously unmuted. This is arguably a simpler solution, but it eliminates the ability to use muting in a more ad hoc way.\nThis second approach suggests to me that the Mute concept might be serving two distinct purposes: that is, in concept lingo, it\u0026rsquo;s overloaded. One purpose is to let participants in a meeting turn off their microphone for privacy, and the other is to control who is allowed to speak. This suggests applying a split move in which Mute is split into Privacy, a concept that lets users control what other users can see and hear of them, and Permission, which grants users the right to be seen and heard. Our merge move may then be applied to Permission and RaisedHand, leaving Privacy as a distinct concept, which might support some needs more directly. For example, Privacy might provide a toggling action for \u0026ldquo;going private\u0026rdquo; when you want to take a brief break.\nAs always, the challenge will be to balance richness of functionality and automation on the one hand with maintaining simplicity and not overwhelming the user with controls on the other.\nLet\u0026rsquo;s help Zoom! Here\u0026rsquo;s an experiment in community design. Let\u0026rsquo;s together develop a design to address the Zoom raised-hands problem in the concept forum. I\u0026rsquo;ll post these initial ideas to get the topic going.\nFrom my newsletter: archives and signup here.\n","permalink":"https://essenceofsoftware.com/posts/design-moves/","summary":"Or how to become a great software designer.","title":"Design Moves for Software"},{"content":"Dark patterns are no longer just yucky strategies that companies get away with, tempting you to buy insurance you don\u0026rsquo;t need or sign up for a free-for-a-while trial that can only be canceled by calling a phone number that is always busy. Soon they might be illegal. Regulators are taking a closer look, and lawyers in the US and the UK are starting to warn about the liabilities they bring.\nBut what exactly makes a pattern dark? Where is the line between an aggressive but legitimate sales tactic and an immoral or illegal scheme?\nA new project In a research project funded by a new NSF program about designing accountable software systems, I\u0026rsquo;m working with my students Geoffrey Litt and Josh Pollock (and my co-PIs Danny Weitzner and Joan Feigenbaum and their students) on answering this question.\nOur initial take involves—surprise!—software concepts. To date, dark patterns work has focused on user interface tricks: getting you to click the big green button, for example, when it\u0026rsquo;s really that small text field that doesn\u0026rsquo;t even look like a button that you want to click instead. But the more serious dark patterns run deeper, and are conceptual in nature.\nAs bad as it gets For example, in one of the most egregious scams I\u0026rsquo;ve ever seen (thanks so Eunsuk Kang for telling me about this), Intuit advertises a version of the Turbotax tax filing app as \u0026ldquo;guaranteed free.\u0026rdquo; In fact, however, as Propublica has documented, the app is far from free, and if you fail to fall within a narrow range of cases, you will be required to pay (after, of course, you\u0026rsquo;ve taken all the trouble to enter your private and personal tax data). Intuit and other tax software companies had lobbied to prevent the IRS from offering its own free solution (as the revenue agency does in many other countries), and in return promised to provide one itself. The free one, it turns out, is not called the \u0026ldquo;Free Edition,\u0026rdquo; but rather the \u0026ldquo;Freedom Edition,\u0026rdquo; and is not reachable from the Turbotax website.\nDark patterns in Facebook Most cases of dark patterns are more subtle. Take Facebook, for example. Suppose Alice posts a photo of Bob, and Carol (a friend of them both) then tags Bob in the photo. This seemingly innocent action has an unexpected and pernicious consequence: it makes the photo visible to all of Bob\u0026rsquo;s friends, even those who are not friends of Alice or Carol. Perhaps the photo shows Bob at a job fair talking to a competitor and his friends include his work colleagues. There are all kinds of reasons that Bob might not want the photo to be shared in this way.\nNow Facebook would likely respond that its users should know how the app behaves, and that they are free to choose more stringent privacy settings. Bob could have turned on a \u0026ldquo;tag review\u0026rdquo; setting that would have required his approval before the photo was shown to all his friends. In practice, of course, most users don\u0026rsquo;t have a clue what\u0026rsquo;s going on, or how to change their settings. And not surprisingly, the defaults seem to favor Facebook rather than its users.\n(I\u0026rsquo;ve written a piece for a lay audience about how Facebook uses \u0026ldquo;dark concepts\u0026rdquo; to further its sometimes nefarious business practices: you can find it here.)\nThe key idea Here\u0026rsquo;s our idea. What\u0026rsquo;s wrong with simple UI dark patterns is that they confound the expectations of the user: you think that big green button is the normal approval of your purchase, but it turns out to be the one that signs you up with extra insurance that you didn\u0026rsquo;t want to buy. Patterns that operate more deeply also confound expectations, not about the meaning of user interface widgets, but about the very behavior of the concept at hand. When you see a familiar concept like a shopping cart, you bring with you all your prior experiences of shopping carts, so you assume this shopping cart will be no different. You don\u0026rsquo;t expect items to be added to the cart spontaneously without your approval; shopping carts just don\u0026rsquo;t do that.\nThe use of a common concept thus establishes a kind of implicit contract between the company and the consumer. In exactly the same way, if an employee of a supermarket came and dropped items into your cart because they \u0026ldquo;thought you might like them,\u0026rdquo; your grounds for objection should not be that such an action is inherently evil. It\u0026rsquo;s that shopping carts just don\u0026rsquo;t work that way.\nFacebook\u0026rsquo;s concepts Let\u0026rsquo;s apply this idea to Facebook. Our task is to come up with plausible concept definitions that capture our expectations of activities such as posting, friending and tagging. This will not be easy because apps like Facebook are so baroque that arguably our expectations are uncertain and inconsistent. So instead we\u0026rsquo;ll try to imagine how an app like Facebook might work if it were designed to be as simple and clear as possible.\nOur first task is to identify the essential concepts, and assign each a compelling purpose and a role with respect to privacy. For example, we might come up with the following concepts and purposes:\nPost: author content Comment: respond to content by others Friend: control access to your content Tag: identify users in images  Even these apparently simple purposes are not uncontentious. The Friend concept, for example, is also used to filter content (so that you see content that you\u0026rsquo;re interested in). This purpose arguably belongs to the Follower concept, however, which in Facebook is merged into the Friend concept. But this issue need not bother us here, since privacy is our primary concern.\nNow let\u0026rsquo;s assign privacy roles to concepts:\nPost: determines who can edit content (the author) Comment: determines who can edit response (its author) Friend: determines who can see content (friends of the content publisher) Tag: no role  The privacy roles of Post and Content are straightforward: they control only who can edit the post or the comment (namely the author who wrote them in the first place). Deciding that Tag has no privacy role is obviously inconsistent with the way it behaves in Facebook, but we\u0026rsquo;re laying out the simple case for now. Friend is the interesting one here, and as we\u0026rsquo;ll see, what\u0026rsquo;s tricky is defining who publishes given content.\nAs we enumerate these concepts and their roles, we realize that we have covered reading and editing (and implicitly creating, assuming that each concept governs the creation of its namesake items), but not deletion. So we add one more concept\nOwner: manage deletion of items  that will determine who is allowed to delete which items.\nDefining states Our next task is to outline the behavior of the individual concepts. The interesting case is Friend. We start with the state components (aka the data model):\npublishes: User -\u0026gt; set Item friends: User -\u0026gt; set User sees: User -\u0026gt; set Item = friends.publishes  The publishes relation will track which items have been published by which users. Note that I wrote Item and not Post or Comment or Tag. No concept should depend on the existence of any other; we should be able to understand Friend without knowing what form the items that are published will take. From Friend\u0026rsquo;s point of view, only the identity of an item matters, and Item can be viewed as a type variable (so that Friend is generic over all possible items).\nNote also that the Friend concept maintains its own record of which item was published by which user; it can\u0026rsquo;t refer to a relation in some other concept (such as which items are owned by which users in the Owner concept, or which posts are authored by which users in the Post concept). This might seem to be redundant, but in fact it isn\u0026rsquo;t: we\u0026rsquo;ll see that the publishes relation does not neatly align with these other relations in the other concepts. You can own an item but not publish it, for example.\nFinally, the sees relation defines which items a particular user can see. It is not a state component that can be independently updated, but is instead defined in terms of the other state components. The expression friend.publishes uses the Alloy join operator, and associates with a user the set of items published by that user\u0026rsquo;s friends.\nDefining actions To complete the behavior of the individual concepts, we define actions. For Friend, for example, we might have the following actions, each with a comment giving its effect on the state:\npublish (u: User, i: Item) // add i to u.publishes friend (u, u’: User) // adds u to u’.friends and vv unfriend (u, u’: User) // removes u from u’.friends and vv read (u: User, i: Item) // blocks unless i in u.sees delete (i: Item) // remove item  Of course these specs can be written precisely in a language like Alloy and—in addition to being precise—that would let you do automatic simulation and analysis. But that\u0026rsquo;s a story for another day. The important things to note here are: (a) that the read action is a kind of placeholder; it doesn\u0026rsquo;t really do anything except block if the user isn\u0026rsquo;t allowed to see the item; and (b) that the publish action is not called \u0026ldquo;post\u0026rdquo; or anything that like, because it will be in the composition with other concepts that we get to decide what comprises publishing.\nDefining synchronizations Now we can put things together, and define the overall behavior by synchronizing the actions of the individual concepts. I\u0026rsquo;ve only shown you the actions of the Friend concept, but I think you\u0026rsquo;ll be able to figure out what the actions of the other concepts do from their names.\nHere are two synchronizations:\napp fb includes Post, Comment, Tag, Owner, Friend, … // when user u adds a comment c to post p sync Comment.add_comment (u, p, c) // the author of the comment becomes its owner Owner.create (u, c) // the owners of the post become owners of the comment Owner.add_owners (p.(Owner/owners), c) // the comment is published by the publisher of the post Friend.publish (p.(Friend/publishes), c) // when user u adds tag t to item i for user m sync Tag.tag (u, m, t, i) // creator of tag becomes owner Owner.create (u, t) // mentioned user becomes owner too, so can delete Owner.add_owners (t, m) // tag itself is published by publisher of item Friend.publish (i.(Friend/publishes), t)  The first one describes what happens when the user adds a comment. That action produces three additional actions: the user who adds the comment becomes an owner of the comment; the owners of the post (on which the comment is made) become owners of the comment; and the comment is published by the publisher of the post. The expression p.(Friend/publishes) uses Alloy\u0026rsquo;s nifty dot operator to navigate backwards from the post p through the publishes relation in Friend to obtain the set of users that are the publishers of p.\nAs a result of these actions, when Alice adds a comment to Bob\u0026rsquo;s post, only Alice can edit the comment (since authorship is maintained in the Comment concept); both of them can delete the comment (since they are both owners, and the Owner concept lets owners delete items); and the comment is deemed to have been published not by Alice but by Bob. This last part is critical for our exploration of privacy in Facebook: it\u0026rsquo;s what ensures that it\u0026rsquo;s Bob\u0026rsquo;s friends, and not Alice\u0026rsquo;s friends, who see the comment.\nThe second sync says what happens when a user tags an item. Both the tagger and the tagged person are owners, so the tagged person can delete the tag if they don\u0026rsquo;t like it. More interestingly, the effect of tagging includes making the tag published by the publisher of the item. So this means that the tag is visible to the same set of users as the item it\u0026rsquo;s attached to.\nModeling the way Facebook really is This is not how Facebook works by default, although you can get this behavior by tightening your privacy settings. Here is a sync that describes Facebook\u0026rsquo;s default behavior:\n// when user u adds tag t to item i for user m sync tag.tag (u, m, t, i) ... // owners as before // tag itself is published by publisher of item friend.publish (i.(Friend/publishes), t)\t// tagged person becomes a publisher of the item friend.publish (m, i)\t// tagged person becomes a publisher of the tag friend.publish (m, t)  In this variant, the person tagged (m) additionally becomes a publisher of both the tag and the item tagged: that means that all their friends will see the tagging.\nWhat have we gained? By describing the Facebook design in terms of concepts, we\u0026rsquo;ve achieved a few things:\n  We\u0026rsquo;ve factored the behavior into understandable pieces. In particular, the Friend concept is responsible for managing visibility, and encapsulates a very simple rule: you can see what your friends publish.\n  Because concepts can be combined by synchronization, we can describe behaviors in which actions happen not only because they are directly initiated by the user (such as adding a comment), but also because they occur implicitly, in combination with other events (such as the publishing of the comment by the author of the associated post).\n  We can now disentangle things, When Alice tags Carol in Bob\u0026rsquo;s post, who is publishing what? In the design we proposed as the sane one, Bob is the publisher of the tag, just as he would be the publisher of a comment that Alice made on his post. And thus the audience of the post is not expanded by the act of tagging. In contrast, in the Facebook design, when Alice tags Carol in Bob\u0026rsquo;s post, Carol is deemed to be publishing not only the tag but also the original post!\n  We can now judge the various design options, distinguishing sane and straightforward designs from those that are at best baroque and at worst malicious. For example, the case for arguing that any follow-up to a post is treated as published by the author of the post is straightforward, and corresponds to the idea of the whole discussion being \u0026ldquo;hosted\u0026rdquo; by that author. The case for the actual Facebook design, in which a tagged person is deemed to republish the post as a whole, seems much harder to defend.\n  Where does this all go? The upshot of this rather lengthy (and in places complicated) discussion can be stated simply. A user interacts with a software system by executing a series of actions. In an honest design free of dark patterns, which actions occur, and the effect of those actions, align with the user\u0026rsquo;s expectations. Those expectations are set by the assumptions that the user brings to the interaction, based on prior experiences with similar systems. They include simple expectations about the user interface itself (for example, that green means go and red means stop), and deeper expectations about the underlying functionality (for example, that items don\u0026rsquo;t spontaneously get added to a shopping cart). Concepts provide a way to identify recurring units of functionality, and thus to articulate these assumptions.\nThese ideas could be used to make apps such as Facebook more transparent and accountable to their users. An industry standards body could agree on the definition of concepts such as Friend, and Facebook would then be encouraged (or perhaps required) either to conform to that concept, or make it very clear that their concept was not compliant. Along with this, Facebook would be required to explain in simple terms who is publishing what, so that a user can figure out how actions in other concepts are interpreted as publishing actions from the point of view of Friend.\nAdmittedly, this isn\u0026rsquo;t simple. But it\u0026rsquo;s surely simpler than the status quo, in which the user is faced with a complex data model of posts, comments, replies, tags and friends, and very little structure that would allow them to understand what\u0026rsquo;s really going on.\nThis post has been edited, based on very helpful discussions with Rebecca Jackson and Eunsuk Kang. Thank you to both of them. Thank you also to Jimmy Koppel for pointing me to Joel Spolsky\u0026rsquo;s story in which he experienced \u0026ldquo;sneak into basket\u0026rdquo; in a physical store.\n","permalink":"https://essenceofsoftware.com/posts/facebook/","summary":"What\u0026rsquo;s really going on with dark patterns?","title":"Facebook and Dark Patterns"},{"content":"Basic sys admin tasks can be surprisingly hard. You find some magic incantations online, which you dutifully type into a terminal, but then they don\u0026rsquo;t have the desired effect. What now? At that point, you\u0026rsquo;re usually stuck with no recourse (except to start an endless descent into online forums).\nI had this experience recently trying to install Jekyll, a static website generator. Despite trying for a few hours, I just couldn\u0026rsquo;t do it. So I switched to Hugo, a similar tool that offers an executable image so you don\u0026rsquo;t have to build it yourself. Downloading a file and executing it is fortunately something I\u0026rsquo;m capable of doing (although even that has become harder with Apple\u0026rsquo;s security protections).\nWhy are these simple tasks often so challenging? In large part, it\u0026rsquo;s because the underlying concepts are both complicated and fragile, so you need to know a lot—and understand them more deeply than should be necessary— to work around their rough edges.\nDNS and DKIM Here\u0026rsquo;s an example, involving two concepts—one you\u0026rsquo;re probably familiar with and one that might be new to you. The first is domain name resolution, and is the central concept of DNS (the Domain Name System). Its purpose is to decouple long-lasting domain names from the ephemeral machine addresses that serve them. The operational principle, roughly, is that the owner of a domain provides the domain name and an IP address, and subsequent lookups for that domain resolve to that IP address. The concept works hand-in-hand with the domain registration concept, which manages the process by which an owner acquires a domain (along with permission to update its DNS records), and the concepts corresponding to the various protocols that use DNS, such as http.\nThe second is domain keys identified mail (DKIM), a concept whose purpose is to reduce email spoofing. The operational principle is that the owner of a domain signs the from-address of an outgoing email message (along with some other fields from the email header) with the domain\u0026rsquo;s private key, and places the signature in the header; the recipient then uses the domain\u0026rsquo;s public key to check the signature, rejecting the message if the check fails. Assuming no other server has access to the domain\u0026rsquo;s private key, this ensures that only the legitimate servers of that domain can successfully sign messages, and messages that purport to come from that domain but are actually spoofing the from-address will be rejected.\nGetting the Key How does the recipient obtain the domain\u0026rsquo;s public key? It could send a request to the outgoing email server, but that would require the server to support a special protocol. Instead, the key is stored as a DNS record. In addition to the records used for the domain name resolution concept, the domain name system includes a special \u0026ldquo;TXT\u0026rdquo; record type that is used to hold protocol-specific details associated with a domain. Thus a domain owner can create a record for DKIM that holds the DKIM public key.\nTXT records have proliferated with the growth of new applications. Unfortunately, the DNS query that returns TXT records returns all the TXT records associated with a domain, and the recipient has to sort through them to find the relevant record. For this reason (and others), a new approach has become popular, in which the DKIM key is placed not in a TXT record, but in a CNAME record. CNAME, which stands for \u0026ldquo;canonical name\u0026rdquo; is a form of record used for domain name aliasing: it lets you map one host name within your domain to another. It is commonly used, for example, to redirect a name such as www.dnj.photo to dnj.photo.\nSo how is this done? Here\u0026rsquo;s the trick. You create a CNAME record that maps a name like s1._domainkey.foo.com to the name of a host that, when queried, will provide the DKIM key (thus also introducing a useful layer of indirection, so you can change the DKIM key without changing the DNS record). In this name, s1 is called a \u0026ldquo;selector\u0026rdquo; and is used by DKIM to select one key over another (so that you can rotate keys for example, or have different keys for different email services), and foo.com is the email-sending domain that is being authenticated. The funny part is _domainkey. That\u0026rsquo;s an actual string, not a placeholder, and its purpose is to ensure that the whole name is interpreted as a label for a DKIM key, and not as a regular domain name.\nUnderscoring the Problem This tactic risks polluting the namespace of your domain, and that\u0026rsquo;s why the DKIM designers included the underscore. Perhaps you have a host name called domainkey, but surely you wouldn\u0026rsquo;t want a host name that starts with an underscore? In fact, underscores cannot appear in host names according to IETF standards. But then, since CNAME records map host names, shouldn\u0026rsquo;t an underscore be prohibited there?\nRFC2181 attempted to clarify this issue, insisting that DNS is a general database, and is not just for domain name resolution, and the names that appear as labels in DNS records can thus be arbitrary strings. That\u0026rsquo;s all very well, but it\u0026rsquo;s not consistent with the intended role of CNAME records, which is precisely to map host names! Another article noting this confusion explains that \u0026ldquo;there are many DNS entries that are not host names,\u0026rdquo;\u0026quot; which seems to imply that CNAME records, whose labels generally are host names, should indeed be excluded from the looser rule.\nNot surprisingly, some DNS providers reject underscores in CNAME records, and this means that if your mail service needs DKIM keys to be stored in CNAME records, you\u0026rsquo;re hosed. ()\nWhat\u0026rsquo;s going on here? In short, to support DKIM, the domain name resolution concept has been overloaded. This is a form of overloading I call \u0026ldquo;piggybacking\u0026rdquo; in my book, in which a developer wanting to add some function finds some existing concept to support it, even though it doesn\u0026rsquo;t quite fit.\nHere, the new function is using DNS for mapping application-specific attributes to values. By squeezing this functionality into the existing domain name resolution concept, and the CNAME record in particular, we now have a mess in which some \u0026ldquo;host names\u0026rdquo; aren\u0026rsquo;t in fact names of hosts, and DNS providers differ on how they interpret the rules about whether such a name can have an underscore.\nWhat\u0026rsquo;s the alternative? Instead of piggybacking, DNS might have been extended with a new concept, allowing lookups in which you give a domain name (foo.com) and an application-specific attribute (dkim, say), and the DNS server returns the associated value (the DKIM public key). A new standard for TXT records could support such a concept.\nNo Big Deal? Now you might say that I\u0026rsquo;m making a mountain out of a molehill, and that these are small complications. But in practice, it\u0026rsquo;s a mass of small, self-inflicted wounds of this sort that make many systems so complex and fragile. It turns out that DKIM—as well as SPF and DMARC, the other protocols used to prevent mail spoofing—can often be broken by hackers, because of exactly this kind of non-uniformity (for example, in parsing email addresses).\nPiggybacking will always seem cheaper and easier than modifying a concept or creating a new one. But the eventual price may be much higher.\nFrom my newsletter: archives and signup here.\nUpdate A few updates and corrections, following some further investigation and input from DNS experts:\nDNS as a general database. The earliest RFCs mention DNS holding information beyond host addresses—including phone numbers for CSNET, for example—and make it clear that the resource records were not to be limited to the initial types. It wasn\u0026rsquo;t until later, though, that the idea of DNS as a general key/value store seems to have emerged explicitly. Jerry Saltzer, who developed a name service for Athena at MIT called Hesiod, told me that Paul Mockapetris added the TXT resource type to support more general lookups, as required by applications such as Hesiod.\nDomain names as intentional names. Domain names that included property labels go back at least to Hesiod, which used an @-symbol to separate the property-specifying part from the rest, eg. finger-server@berkeley.mit.edu. A project at MIT in 1999 explored this general idea, in which a name does not designate a service directly, but rather specifies the properties for a desired service, and called it intentional naming. In 2000, RFC 2782 described the addition of the SRV resource type, which mapped domain names of the form _service._protocol.name to server/port names, allowing intentional names such as _ldap._tcp.foo.com.\nDomain names that include property keys. A domain name like domainkey.foo.com is not an intentional name that specifies a service. The DKIM protocol does not require a service; all that\u0026rsquo;s needed is for the DKIM key to provided for the domain. Instead, this domain name is a combination of a domain name (foo.com) and a key to be looked up in the DNS records of that domain name.\nUnderscores in domain names. The use of underscores in these extended forms of name prevented conflicts with hostnames, but introduced the new risk of the new labels conflicting. In 2019, RFC 8552 described the convention of naming with underscored labels, and introduced a registry to avoid collisions.\nUnderscore confusions. The early RFCs said that domain names should be as general as possible, but confusing wording misled many people. A much-quoted statement from RFC 882 seems to say that underscores are not permitted in the labels that comprise domain names: \u0026ldquo;The labels must follow the rules for ARPANET host names. They must start with a letter, end with a letter or digit, and have as interior characters only letters, digits, and hyphen.\u0026rdquo; This statement, however, seems on closer reading to be an informal explanation for a grammar that is not intended to be mandatory: \u0026ldquo;The preferred syntax of domain names is given by the following BNF rules. Adherence to this syntax will result in fewer problems with many applications that use domain names (e.g., mail, TELNET).\u0026rdquo; This complicated position is elaborated in RFC 1035 which states:\nThe DNS specifications attempt to be as general as possible in the rules for constructing domain names. The idea is that the name of any existing object can be expressed as a domain name with minimal changes. However, when assigning a domain name for an object, the prudent user will select a name which satisfies both the rules of the domain system and any existing rules for the object, whether these rules are published or implied by existing programs.*\nNot surprisingly this has confused even experts; a ballot amongst a consortium of companies voted to sunset the use of underscores in DNS names appearing in certificates, citing the statement in 1035 that \u0026ldquo;labels must follow the rules for ARPANET host names\u0026rdquo; which it took, incorrectly, to specify \u0026ldquo;the characters which may be used in DNS domain names.\u0026rdquo;\u0026quot;\nCNAME records for DKIM. Use of CNAME resource records for DKIM is not (I believe), as I originally suggested above, to avoid the use of TXT records, but rather to provide an extra level of indirection so that a domain can delegate to a hosting service the job of assigning (and rotating) DKIM keys. The use of the _domainkey prefix alone would limit the number of TXT records returned, since the extended domain name has a different set of resource records associated with it than the base domain name.\nRefining the concept design analysis. In summary, there are (at least) three distinct concepts in play here. First there is the concept of a HierarchicalName, which allows a name space to be divided into separately managed zones. This concept is familiar from file systems, and from the structure of many web APIs (which use so called \u0026ldquo;RESTful\u0026rdquo; names for resources). Second is the concept of IntentionalName, in which a name becomes a kind of specification. This also existed prior to DNS, although the concept has been less widely adopted. Third is the concept of Metadata in which an object has a collection of properties associated with it; a photo, for example, has its capture time and exposure; a file has its creation time; a DNS domain has its domain key.\nThe lens of concept design helps us recognize that much of the richness of DNS that we have explored comes from the fact that three distinct concepts are being offered. The familiarity of these existing concepts should make DNS easier to understand.\nWhat is unusual is that all three concepts are implemented by the same mechanism. In concept lingo, the second and third concepts are \u0026ldquo;piggybacked\u0026rdquo; onto the first concept, with the properties and specifiers of Metadata and IntentionalName respectively both represented as labels in a prefix of a domain name. Like many piggybacking designs, this is ingenious and solves some problems. In particular, it allowed DNS itself to remain unchanged, without the need for new resource types or mechanisms (although it did require the creation of a new registry to avoid name clashes).\nThe downside is that piggybacked concepts generally cannot be fully supported by a mechanism that was not designed for them. A full implementation of IntentionalName, for example, would allow wildcard specifiers, so that for example one could request not only a color printer _printer._color.local.foo.com or a monochrome printer _printer._mono.local.foo.com but also any printer _printer.*.local.foo.com whether color or monochrome. As noted in RFC8552, DNS cannot support such wildcards. Another price paid for the piggybacking is some additional complexity involved in squeezing the new functionality into a Procrustean bed—here, the underscore, and all the confusion created about whether it is permitted.\nWhether the DNS design is bad or good is not the main issue here—and now I have a better appreciation of the tradeoffs I am less inclined to insist that this piggybacking is a mistake. What my analysis shows, I hope, is that concept design can reveal the underlying issues and make clearer whatever tradeoffs are being made.\nMany thanks to Dave Crocker, Jerry Saltzer and Garrett Wollman who generously shared with me their expertise on DNS.\n","permalink":"https://essenceofsoftware.com/posts/dns-dkim/","summary":"Or why basic sysadmin tasks are so hard.","title":"Concept Piggybacking in DNS"},{"content":"I\u0026rsquo;m always excited to find examples outside software that concept design can be applied to. Here\u0026rsquo;s one I came across this week.\nAs part of a restructuring of our curriculum, we\u0026rsquo;re fixing up our class numbers. Currently, our programming sequence looks like this:\n6.0001 Introduction to CS and Programming using Python 6.009 Fundamentals of Programming 6.031 Software Construction 6.170 Software Studio  After renumbering, it might become:\n6.100 Introduction to CS and Programming using Python 6.101 Fundamentals of Programming 6.102 Software Construction 6.103 Software Studio  Surprisingly, making such a change actually turns out to be really hard. One major problem is that (because we have a large department with many classes) this would require reassigning some existing numbers. But MIT\u0026rsquo;s registrar has a rule that you can\u0026rsquo;t reassign a class number unless it has been unused for five years!\nWhat\u0026rsquo;s going on here? The concept of class number has multiple, conflicting purposes: in concept lingo, it\u0026rsquo;s overloaded. One purpose is to be a shorthand that signals the role that the class plays in degree requirements. This includes the level of the class (thus hinting that 6.101 would be taken before 6.102) and, in the case of our renumbering, also the general area the class belongs to (thus 6 says it\u0026rsquo;s a class in EECS, and 6.1 that it\u0026rsquo;s in the software track).\nThe other purpose is that the number acts as a name that persists from term to term (so students and prospective employers can assume that 6.103 is consistent from year to year, for example). It\u0026rsquo;s because of this second purpose that the registrar forbids reassignment of numbers without a five-year gap.\nWhat\u0026rsquo;s the solution to this dilemma? The standard concept design move would be to split into multiple concepts, one for each purpose. We could add a mnemonic name (or commandeer the course title) to serve the naming purpose, and reserve the number for signaling the place in the curriculum. So then we might have, for example:\n6.100 Software Intro 6.101 Software Fundamentals 6.102 Software Construction 6.103 Software Studio  Is this a reasonable solution? I\u0026rsquo;m not sure. It would require a culture change at MIT to refer to a class by a name (\u0026ldquo;software studio\u0026rdquo;) rather than a number (\u0026ldquo;103\u0026rdquo;). On the other hand, encouraging more mnemonic names might be a good thing and would help beyond the university: I remember that Tim Nelson\u0026rsquo;s class that teaches Alloy at Brown is called \u0026ldquo;Logic for Systems\u0026rdquo; and not that its number is \u0026ldquo;CSCI 1710\u0026rdquo;. And the alternatives are not much better. One ingenious proposal is to satisfy the registrar\u0026rsquo;s rule by appending a zero to each number, and then remove it after five years.\nI wonder if there\u0026rsquo;s a better conceptual solution. Let me know if you can think of one!\nFrom my newsletter: archives and signup here.\n","permalink":"https://essenceofsoftware.com/posts/class-numbers/","summary":"Who knew such a simple thing could be so challenging?","title":"The Class Number Dilemma"},{"content":"This article summarizes the key ideas in the book The Essence of Software. It is not intended to be understandable by itself. It gives almost no examples, makes claims without justifying them, and cites almost no related work. And it\u0026rsquo;s not nearly so much fun to read as the book :-). But, hey, at least it\u0026rsquo;s short(ish)!\nIf you haven\u0026rsquo;t read the book, I recommend that you don\u0026rsquo;t start with this, but watch my ACM talk instead. But perhaps you don\u0026rsquo;t really want to read the book, and just want to be able to hold your own at a cocktail party showing off your sophistication in software design. In that case, this may be for you.\nIf you\u0026rsquo;ve read the book, this summary should be a useful reminder of the key ideas, to help you solidify them in your mind and relate them to other approaches. In this sense, it augments the shorter list of provocative questions in Chapter 12 of the book.\nA final warning before you jump in: this summary assumes a fairly extensive background in software design and development. The book itself is aimed at a broader audience, introduces the ideas more gently by way of example, and relegates the harder technical stuff to end notes.\nDefining Software Design In most fields, \u0026ldquo;design\u0026rdquo; means shaping an artifact to meet the needs of users, thus sitting at the boundary between humans and machines. Despite Kapor\u0026rsquo;s notable manifesto in 1990, and the book edited by Winograd that followed in 1996, little attention has been paid to software design.\nEnormous effort, in contrast, has been devoted to software engineering (whose interest instead is software\u0026rsquo;s internal structure and means of construction). This disparity of attention has resulted in great advances in programming, represented by a major body of knowledge and well-known design principles.\nThe field of human-computer interaction has likewise produced an impressive body of knowledge about user interfaces and how they shape the way we understand and use software. But for software design, where the focus is on the fundamental abstractions that underlie both the interface and the implementation, our knowledge is much more limited, and we have had to be content with being guided instead by vaguer notions, and (albeit sensible) appeals to simplicity and clarity.\nThe Book\u0026rsquo;s Aims and Approach The aims of the book are to highlight a central aspect of software design; to lay out a way to structure and express software designs from this perspective; to provide some heuristics and principles for design; and, more generally, to inspire a renewed focus on software design as a discipline.\nThe book is driven by examples drawn from over 100 apps. By focusing on widely used software produced by the best companies, it seeks to show that serious problems are rife, and challenge even the most talented developers, and that the book\u0026rsquo;s ideas and techniques apply to real software.\nThe book presents a design approach comprising simple textual and diagrammatic notations, a collection of readily applicable heuristics, and some deeper principles. In order to explain the approach in more detail, and to show how it differs from many prior approaches, a collection of end notes is included covering topics from design thinking to formal methods.\nThe Problem Software is harder to use than it needs to be. We spend an increasing portion of our lives engaged with software apps and systems, so improving the design of software impacts the quality of our lives and our ease of working effectively together.\nAs software becomes an ever more critical part of our civic infrastructure, we rely on apps and systems to behave predictably and reliably. A high proportion of failures are due to user errors, for which poor design is usually to blame. And even when a failure is attributed to a bug in the code, it is likely that the bug is due to lack of clarity in design (rather than a simple failure to meet a specification).\nLack of clarity in software design also makes software harder to build, and leads to degradation over time as accretions to a codebase compromise its modularity yet further.\nLevels of Design Software design activities and criteria can be assigned to three levels: physical, which concerns the choice of colors, type, layout, etc, and is influenced by particular human anatomical and cognitive capabilities; linguistic, which concerns the use of icons and labels, terminology, etc, and is dependent on shared cultural and linguistic assumptions; and conceptual, which concerns the underlying semantics of the application, including the actions that can be performed and the effects they have, and the structure and interpretation of the state as viewed by the user.\nThe conceptual level is the most fundamental; different physical and linguistic designs for an app might be equally effective, but even small changes to the conceptual design are usually very disruptive to users. Users' problems with apps arise more often from incorrect conceptual understandings than from an inability to interpret the physical and linguistic signals of the user interface.\nThis is due in part to the great advances that have been made in the last decades at the physical and linguistic levels. Many books and online collections of heuristics teach user interface design very effectively, and given also that many client-side frameworks now provide professionally designed widgets, there is little excuse nowadays for a design that fails at these levels.\nPrior Work on Conceptual Design The importance of the conceptual level has been recognized for more than half a century. From early on, researchers noted the importance of a user\u0026rsquo;s \u0026ldquo;mental model\u0026rdquo;, and the need for the design to construct such a model explicitly, so that the user\u0026rsquo;s model and the system model coincide. Fred Brooks coined the term \u0026ldquo;conceptual integrity\u0026rdquo; and argued that the conceptual aspects of software design represented the essence of the field, as opposed to the accidental aspects, to which he relegated the concerns of \u0026ldquo;representation.\u0026rdquo; The fields of conceptual modeling, domain modeling and formal methods all emphasized the centrality of an abstract model of state (and, in the case of formal methods, also behavior) in the design of software.\nAnd yet none of these fields expressly addressed the problem of designing the conceptual structure of software in order to meet the needs of the user and to align the user\u0026rsquo;s understanding. Formal methods focused primarily on the problem of correctness, and ensuring conformance of the implementation to the model. Conceptual modeling and domain modeling focused primarily on the representation of knowledge about the context of operation of a system, rather than on the structures that the designer invented.\nMost curiously missing was a well defined notion of \u0026ldquo;concept.\u0026rdquo; Even in the field of conceptual modeling, there is no shared understanding of what a concept might be, or even well-known candidate definitions. An entire conceptual model seems to be too large to count as a single concept, and its constituent entities (or classes or objects) are too small, especially since an informal understanding of a concept tends to involve relationships amongst multiple elements.\nA New Definition of Concept A concept is a reusable unit of user-facing functionality that serves a well-defined and intelligible purpose. Each concept maintains its own state, and interacts with the user (and with other concepts) through atomic actions. Some actions are performed by users; others are output actions that occur spontaneously under the control of the concept.\nA concept typically involves objects of several different kinds, holding relationships between them in its state. For example, the Upvote concept, whose purpose is to rank items by popularity, maintains a relationship between the items and the users who have approved or disapproved of them. The state of a concept must be sufficiently rich to support the concept\u0026rsquo;s behavior; if Upvote lacked information about users, for example, it would not be able to prevent double voting. But the concept state should be no richer than it need be: Upvote would not include anything about a user beyond the user\u0026rsquo;s identity, since the user\u0026rsquo;s name (for example) plays no role in the concept\u0026rsquo;s behavior.\nConcept Reuse and Familiarity Most concepts are reusable across applications; thus the same Upvote concept appears for upvoting comments in the New York Times and for upvoting answers on Stack Overflow. A concept can also be instantiated multiple times within the same application.\nThis archetypal nature of concepts is essential. From the user\u0026rsquo;s perspective, it gives the familiarity that makes concepts easy to understand: a user encountering the same context in a new setting brings their understanding of that concept from their experience in previous settings.\nFrom a designer\u0026rsquo;s perspective, it allows concepts to be repositories of design knowledge and experience. When a developer implements Upvote, even if they can\u0026rsquo;t reuse the code of a prior implementation, they can rely on all the discoveries and refinements previously made. Many of these are apparent in the behavior of the concept itself, but others are associated with the implementation, or are subtle enough to need explicit description. The community of designers could develop \u0026ldquo;concept catalogs\u0026rdquo; that capture all this knowledge, along with relationships between concepts (for example, that Upvote often relies on the Session concept for identifying users, which itself is associated with the User concept for authenticating users).\nConcept Independence Perhaps the most significant distinguishing feature of concepts, in comparison to other modularity schemes, is their mutual independence. Each concept is defined without reference to any other concepts, and can be understood in isolation.\nEarly work on mental models established the principle that, in a robust model, the different elements must be independently understandable. The same holds in software: the reason a user can make sense of a new social media app, for example, is that each of the concepts (Post, Comment, Upvote, Friend, etc) are not only familiar but also separable, so that understanding one doesn\u0026rsquo;t require understanding another.\nConcept independence lets design scale, because individual concepts can be worked on by different designers or design teams, and brought together later. Reuse requires independence too, because coupling between concepts would prevent a concept from being adopted without also including the concepts it depends on.\nPolymorphism is key to independence: the designer of a concept should strive to make the concept as free as possible of any assumptions about the content and interpretation of objects passed as action arguments. Even if a Comment concept is used within an app only for comments on posts, it should be described as applying comments to arbitrary targets, defined only by their identity.\nPushing polymorphism as far as possible is a useful strategy: for getting to the essence of a concept; for finding other opportunities to use a concept within the same app (and in other apps); for discovering that what appears to be an app-specific concept is actually a general and familiar one; and, when it\u0026rsquo;s not possible, for identifying concept subtleties or design flaws.\nConcepts can be implemented independently also; in the Deja Vu platform, Santiago Perez De Rosso showed how apps could be constructed by glueing together reusable, full-stack concepts drawn from a library.\nA Structure for Describing Concepts To work with concepts, we need a simple structure for describing them. A concept is defined by its behavior, which comprises its state space and a set of actions. These can be defined using standard methods and notations.\nFor defining the state space, a data model is given that consists of a collection of components, each of which is a scalar/option, set or relation (of any arity). This model can be recorded with textual declarations or as an extended entity-relationship diagram. The details of the data model are not fundamental to concepts, and different models could be used. What is important is that the state of a concept is (by default) visible to users, so states should make sense to users (and at the very least should be defined explicitly in the spirit of \u0026ldquo;model-based specification\u0026rdquo; rather than implicitly by algebraic axioms).\nActions can be initiated by the user or by the system, and a single action can have both inputs and outputs. A single action can abstract what would be an entire use case in object-oriented modeling approaches, allowing a much terser form of description. An action can also abstract away (that is, not represent in detail) the creation of complex inputs; for example, an action input may be a rich-text object that in the implementation would be produced by an extended interaction with a rich-text editor.\nActions read and write states. An action may have a precondition that makes it applicable only in certain states; when the precondition does not hold, the action is blocked and may not occur. Actions can be non-deterministic, resulting in more than one possible outcome for a given pre-state/input combination. But any non-determinism must be exposed in output arguments, so that the state of a concept is always a function of the trace of actions that have occurred so far. For example, an airline reservation concept could have an assignSeat action that picks an arbitrary seat and assigns it to the customer, but the seat must be represented as an output of the action (in addition to appearing in the post-state of the relation that maps customers to seats).\nFrom a data modeling perspective, there is no global data model. Instead, there is a collection of local data models, one for each concept. Each concept\u0026rsquo;s data model is just rich enough to support its actions. (In teaching data modeling, I have found that this makes it much easier for programmers to scope their models. In traditional modeling, it\u0026rsquo;s all too easy to get carried away with building a data model based on ontological observations that are not actually relevant to the design of the system.)\nIf the state and action definitions are written in a formal notation such as Alloy, the concept behavior can be analyzed automatically, with generation of sample executions, comparison of action versions, and checking properties. The modularity that concepts provide amplify the effectiveness of automated analysis. Such analysis is always inherently intractable (the number of executions to check rising super-exponentially with the number of objects in the state), so researchers have always looked for ways to decompose a system into smaller parts. Concepts provide such a decomposition, aligned naturally with the functionality boundaries of the system.\nThe definition of a concept augments this basic behavioral description with two more novel parts explained in more detail below: the purpose and the operational principle.\nConcept Purposes The idea that an artifact should have a purpose distinct from its specification is hardly novel, and many researchers have recognized the importance of purposes, and the impossibility of expressing them fully and precisely (most notably Christopher Alexander in Notes on the Synthesis of Form).\nWhat is novel in concept design is the idea that it is not sufficient for the system or app as a whole to have a purpose (or a collection of purposes). Each concept in its design should have its own purpose. A concept\u0026rsquo;s purpose defines, in a general setting, the reason for its invention and what benefits it offers; in the setting of a particular app, it defines the motivation and justification for including the concept.\nPurposes also clarify subtle distinctions between related concepts. In social media, for example, there are several concepts that may sit behind a \u0026ldquo;thumbs up\u0026rdquo; widget: Upvote, whose purpose is to rank items by popularity so that users (purportedly) see the most valuable content first; Reaction, whose purpose is to convey an emotional reaction to the author of an item; Recommendation, whose purpose is to learn a user\u0026rsquo;s preferences so that subsequent items can be recommended more reliably; and Profile, whose purpose is to track the user\u0026rsquo;s interests in order to target advertising.\nBecause purposes sit at the boundary of the human/computer interface, they cannot be judged formally (the way correctness can, eg). Nevertheless, the book provides criteria for determining whether a purpose is compelling, and when two distinct purposes may be masquerading as one.\nThe Operational Principle A concept definition also includes its operational principle (OP), an archetypal scenario that shows how the concept fulfills its purpose.\nSuperficially, the OP is like a use case, but it plays a very different role. Use cases are a specification notation, and a full spec typically requires many use cases. Use cases are often expressed at a low level too, in terms of the micro-interactions of the user interface (clicking buttons etc). Since a concept\u0026rsquo;s actions fully define its behavior, nothing more is needed to predict how the concept will behave.\nInstead, the OP captures the dynamic essence of the concept, telling the most basic story about how the concept works. Sometimes the OP is so simple it barely even needs stating: when you add a comment to a post, your comment will subsequently appear along with the post (the OP of the Comment concept). But often the OP is more interesting. It may require two distinct scenarios: when you delete a item, you can restore it from the trash; once you empty the trash, though, it\u0026rsquo;s gone forever and its space is reclaimed (Trash). It may need to be quite elaborate in order to demonstrate the purpose and distinguish the concept from similar but less powerful concepts: if you assign a style to two items, and then you update the style, both items will be updated in concert (Style). And it may involve multiple users: after users have upvoted items, the items will be ranked by the number of times they were upvoted (Upvote).\nThe OP may also be aspirational, applying only in ideal circumstances (even if they are typical). It is not true that if you reserve a restaurant table, and then turn up, a table will necessarily be available (since guests at your table may have stayed longer than expected); nor that a successful authentication associated with a user account must have been performed by the same user that registered the account (since someone may have stolen your password). Like many aspects of concepts, the OP may appear to be obvious until you consider things more deeply.\nThe OP often provides the clearest way to explain a concept. To use the PORT elevator system, a rider selects their destination floor on the device in the lobby, which responds with the identifier of the lift car to be taken; the rider enters that car and is taken to their floor. This is complicated enough—and different enough from standard elevators—for the maker (Schindler) to advertise that it\u0026rsquo;s \u0026ldquo;as easy as 1-2-3\u0026rdquo; (namely involves an OP with multiple steps).\nParadoxically a full behavioral description is often less helpful, since (a) it fails to distinguish the essential aspects of the concept design (how style updates effect items) from more arbitrary design decisions (what happens when a style is deleted); and (b) it conveys the motivation for the behavior. For Michael Polanyi, from whose work the idea of the OP is taken, this latter consideration is the key to understanding the difference between design/engineering on the one hand and science on the other (put bluntly, why physics cannot explain how a clock works).\nConcept Synchronization Within an app, concepts can operate largely without interaction: commenting on posts, for example, may be orthogonal to upvoting them. But often concepts need to be coupled together to achieve the app\u0026rsquo;s goals. For example, it may be problematic for users to edit posts after they have been upvoted (since the upvotes responded to content that may have changed). To mitigate this the upvote action of the Upvote concept could be synchronized with the edit action of the Post concept, to prevent edits after a post has been upvoted or to remove upvotes when a post is edited.\nFor some concepts, synchronization is part of their intended usage. An access control concept is intended to suppress some actions in another concept when the user lacks the right permissions; a subscription concept is intended to react to certain actions by generating subsequent notification actions. In these cases, the concept typically offers \u0026lsquo;placeholder\u0026rsquo; actions that are synchronized with the real actions in other concepts: an access control concept may have an access action, for example, which is then pinned to the action to be controlled in another concept.\nSynchronizations are defined reactively: when an action occurs in one concept, some actions should occur in other concepts. Arguments can be passed between actions, so that synchronization includes data flow. Each synchronization is atomic and happens in its entirety or not at all, so if one of the reactive actions is blocked by its concept, the initial action cannot occur either.\nThis model of communication and interaction is inspired by Hoare\u0026rsquo;s CSP, and can be formalized in its terms. A crucial property of the model is that the behavior of each individual concept is preserved. Synchronization can prevent a concept from executing an action, and it can limit the arguments presented to an action, but it can never cause an action to occur (or an output to be produced) that would not be possible for the concept in isolation. As will be explained below, composing concepts maintains their integrity.\nThe synchronization mechanism is also essential for maintaining concept independence and avoiding the need for one concept to \u0026lsquo;call\u0026rsquo; another. At the code level, composition requires mediators to implement the synchronization; these mediators make reference to the concepts, but the concepts themselves remain free of mutual references.\nSynchronization and Automation Synchronization of concepts is often a form of automation, in which the user is saved the trouble of executing a concept action because it follows execution of an action in another concept automatically. Omission of a desirable automation can be attributed to under-synchronization of an app\u0026rsquo;s concepts: in Zoom, for example, the raised hand concept might be synchronized with the audio muting concept so that participants' hands are automatically lowered after they have their turn.\nAutomation preempts the user\u0026rsquo;s manual control and thus, if not configurable, can be problematic. Such automation can be attributed to over-synchronization of an app\u0026rsquo;s concepts: in some calendar apps, deleting in the event concept leads undesirably to declining in the invitation concept.\nSynchronization and Decomposition What an app presents as a single concept may be better understood as a synchronization of multiple component concepts. A hint that such a decomposition is warranted is often found in the presented concept having multiple, conflicting purposes.\nFacebook, for example, appears to offer a \u0026lsquo;like\u0026rsquo; concept, but on closer examination, this concept is a synchronization of several of the concepts described above: Upvote, Recommendation, Reaction and Profile. This synchronization is responsible for some confusions and critical commentary about Facebook\u0026rsquo;s design (notably, that an \u0026lsquo;angry\u0026rsquo; reaction produces a positive upvote—by some accounts counted for more than a simple \u0026lsquo;like\u0026rsquo;). With this decomposition in mind, different design options are easy to see: having separate buttons for \u0026ldquo;I\u0026rsquo;m angry\u0026rdquo; and \u0026ldquo;I want to see more of this kind of post\u0026rdquo;, for example.\nConcept Synergy In most compositions, concepts bring additive value. But in some designs, concepts can take advantage of each other so that one concept achieves its own functionality in part by relying on another concept. This is synergy in the setting of concept design, where the value of putting two concepts together is more than the sum of their individual values.\nAn example is Apple\u0026rsquo;s synergistic composition of the Folder and Trash concepts. By making the trash a folder, the design allows the action of moving items between folders to be used to restore items from the trash. Achieving this synergy is non-trivial, and the book explains its subtle evolution over time.\nAttempted synergies can backfire. A version of Outlook placed system logs (reporting for example on connection failures between client and server) in mail folders as if they were messages, but this led to numerous problems (for example that reports of connection failure could not be delivered to clients if\u0026hellip; connections failed).\nConcept Dependence Diagrams As explained above, concepts are inherently uncoupled and free standing, so they can be understood, designed, evaluated and reused independently. Bringing concepts together in an app does not couple them either, since the synchronization mechanism ensures that each concept will conform to its own behavioral expectations even if its actions are tied to the actions of other concepts. Furthermore, implementation need not introduce any dependencies between concepts.\nThere is a kind of dependence between concepts, however, that is useful to analyze, and that arises in the context of usage in a particular app or system. A concept C1 is said to depend on a concept C2 in an app A when the inclusion of C1 only makes sense if C2 is also present. Note that \u0026ldquo;makes sense\u0026rdquo; doesn\u0026rsquo;t mean that C1 would somehow break if C2 were missing, so there is no traditional software-engineering dependence here. Rather, the dependence reflects an understanding of the role of C1 in A. In a social media app with a Comment concept and a Post concept, for example, Comment might depend on Post because it was included to allow users to comment on posts, and if there are no posts, there\u0026rsquo;s not much point in having comments.\nAs with conventional dependencies, the concept dependence relation can be depicted as a dependence graph or diagram. Dependences have several uses. They determine which orders of explanation of an app\u0026rsquo;s concepts will be intelligible; you\u0026rsquo;d explain posts before comments on posts, for example, They define, implicitly, an entire application family (as the set of subgraphs in which some subset of the concepts appears and a concept never appears without those it depends on). The dependence diagram can thus be used to make scoping decisions about which concepts to include or exclude. Dependencies also suggest a development order: it\u0026rsquo;s better to build Post before Comment, so that comments have targets to be tested on.\nConcept Mapping In an implementation of a concept design, the concepts must be mapped to the user interface, connecting the conceptual level of design to the physical and linguistic levels. Actions might be executed by gestures or button presses, for example, and the states of the concepts will be displayed in various views.\nThe standard techniques and heuristics of user interface design apply directly to concept mapping. The lens of concept design helps focus this work.\nSome concepts present tricky mapping challenges, and good mappings can be part of the design knowledge associated with a concept. For the filtering view in the Label concept, in which a collection of items is filtered by a selected label, for example, it might seem desirable to maintain an invariant that the items displayed are exactly those carrying the label, but this turns out not to be a good idea.\nIn Gmail, the Label concept is used to classify messages, but the user interface shows messages in the context of conversations and associates labels with conversations instead. This mapping design is troubled, and leads to a variety of odd behaviors.\nTesting and Prototyping Are Not Enough A concept design is ultimately evaluated in the context of use, and misfits (in which a design fails to fulfill its intended purpose) are never fully predictable, because they depend on properties of the human environment which may not even be knowable until the design is deployed.\nUser testing offers some limited value, especially for evaluating concept mappings, and for catching egregious flaws, but (unlike real deployment) will rarely encounter the corner cases that are most troublesome in a design. Prototyping is a valuable strategy for exploring candidate designs early on, and indeed many of the practices of design thinking can be fruitfully combined with concept design, and are made more useful by the separation of concerns that concepts offer.\nBut generate-and-test is not a viable method for finding a good design in a large design space, let alone a great design. To do that requires an expert designer who can apply prior knowledge of likely problems and known solutions, often acquired in very different settings. Concepts provide a framework for recording and retrieving such knowledge.\nA note for computer scientists: the known problems of standard concepts are sometimes grounded in technology (eg, the difficulty of achieving consistent views of data in a distributed system) but are more often a result of human behavior (eg, that ticket sales invite scalpers who then drive up prices).\nThe Need for Concept Design Principles Over the last few decades, a rich body of UX design principles has been developed. These include prescriptive adaptations of psychological ideas, such as the Gestalt principles of grouping, which can be used to guide layout design, and James Gibson\u0026rsquo;s notion of affordance, made applicable in user interfaces by Don Norman\u0026rsquo;s principle that affordances should be explicitly \u0026ldquo;signified\u0026rdquo;. Norman\u0026rsquo;s book The Design of Everyday Things introduced several additional principles, such as the idea of \u0026ldquo;mapping\u0026rdquo; (a different usage from concept mapping) in which a user interface mirrors the structure of the domain being controlled. Other pioneers produced explicit collections of principles: Ben Shneiderman\u0026rsquo;s golden rules, Jakob Nielsen\u0026rsquo;s heuristics, and Bruce Tognazzini\u0026rsquo;s principles of interaction design.\nEspecially in the hands of experts, these principles make it possible to design a user interface that is likely to be highly usable, with a low probability of serious usability flaws. Indeed, there is no excuse nowadays for poor user interface design, and user testing is much less important for routine design work (although it\u0026rsquo;s still valuable of course, especially for very novel or critical designs).\nAlmost all of these principles, however, are focused on the physical and linguistic levels of design. New principles are needed at the conceptual level. The book presents three such principles and explains them in detail with many examples from contemporary apps.\nConcept Design Principles Familiarity. When possible, a familiar concept should be preferred to a new, unfamiliar one. With familiar concepts, users can rely on their prior experience, and don\u0026rsquo;t need to learn a concept afresh. And designers can take advantage of the body of knowledge associated with a known concept, reducing the risk of a design with unexpected misfits. The familiarity principle can be seen as an application of a meta principle of consistency: when a purpose arises in an app that has arisen before, the same solution should be used.\nSpecificity. If you draw up a list of the purposes purportedly served by an app, the purposes and the concepts that aim to fulfill them should be in one-to-one correspondence. This implies first that every purpose should have at least one concept that fulfills it, and that every concept has some purpose that motivates it. So much is obvious, although there are examples in real apps (which the book explains) of unhelpful concepts that serve no user purpose, and purposes that are essential to an app that are fulfilled by no concept.\nThe more subtle implications are: no redundancy, namely that each purpose should be fulfilled by at most one concept, and no overloading, namely that each concept should serve at most one purpose. Redundancy is clearly undesirable because it involves a waste of resources (in the designer\u0026rsquo;s work and in the user\u0026rsquo;s understanding). Overloading is a more subtle notion: that a concept that tries to serve multiple purposes is pulled in different directions, and cannot serve any one purpose effectively. This idea is related to the independence axiom in Nam Suh\u0026rsquo;s theory of mechanical design, and to the common observation in programming that each segment of code should have a single goal.\nThe book gives many examples of concepts doomed by overloading, classifying them into different causes for the overloading:\n false convergence, when a concept is designed for two different functions that were assumed (wrongly) to be aspects of the same purpose; denied purpose, when a purpose was ignored by the designer, despite the desires of users; emergent purposes, in which new purposes arise for old concepts, often invented by the users themselves; and piggybacking, when an existing concept is adapted or extended to accommodate a new purpose.  Integrity. This principle says that when concepts are put together into an app, the each concept should continue to behave according to its (app-independent) concept definition. If concepts are composed by synchronization, integrity will be preserved by design. But if composition is more ad hoc, or if concepts are adjusted to suit the larger context of the app, there is a risk of violation. Google Drive, for example, offers a sync concept (not to be confused with concept sync!) in which local files on disk are kept in sync with files in the cloud. But in an egregious violation of integrity of this concept, only conventional files are properly synced, and files associated with Google Apps (such as Google Docs) are treated specially, and are represented on the local disk not by their contents but by a URL. A lack of awareness of this limitation has been catastrophic for some users.\nComparisons to Other Approaches Concept design builds on more than 50 years of advances in a variety of fields, and contributes some new ideas. First, some work that sounds similar but is not really relevant:\n  Concept maps are diagrammatic representations of collections of facts, with each edge representing a proposition that applies a predicate (the label of the edge) to two atoms (the nodes it connects). Concept maps are an application of knowledge graphs; they were proposed as an educational tool. They are \u0026ldquo;conceptual\u0026rdquo; in the sense that predicate logic lets you formalize all kinds of relationships, at any level of abstraction; and since the predicates don\u0026rsquo;t need to be designated (using Michael Jackson\u0026rsquo;s term), they can express ideas that would be hard to nail down precisely. The very flexibility of concept maps seems to limit their leverage in software design.\n  Concept lattices are representations of partial orders between classifications, where the order is set inclusion. Classification is a useful activity but is limited in the context of software design because it doesn\u0026rsquo;t address relationships, and is usually static, so does not address behavior.\n  At the other end of the spectrum, the most closely related work is:\n  Conceptual modeling. The field of conceptual modeling is broad and has many motivations, but part of it is concerned with explicit representations of the structures that underlie both applications and the mental models of users. The emphasis of the field has tended in the direction of ontologies (eg, for reasoning and knowledge representation), or in the direction of domain modeling (eg, for understanding the environment in which a software system operates), and in these respects conceptual structures are usually discovered rather than invented. In contrast, concept design focuses more on concepts as socio-technical inventions that serve a purpose. Most conceptual models are essentially abstract data models (in the spirit of entity-relationship diagrams), although there is work on dynamic models too (although these are hard to distinguish from standard kinds of dynamic models such as Statecharts). What concept design seeks to provide, which seems to be missing from conceptual modeling, is the notion of a identifiable concepts. Without this, there can be no modularity in conceptual models, and it is not possible to talk about concepts as separable contributions, to identify common concepts between models, or to reuse concepts. The terminology of conceptual modeling sometimes seems to imply that the entities of a data model are concepts, but these are not good concepts, since concepts typically involve relationships between objects. Some approaches seek to identify concepts with objects or classes, but this has an implementation flavor to it, since there is rarely a natural way to assign relationships and behavior to a single object or class.\n  Objects and classes. In the early days of object-oriented programming and development, the idea that objects naturally mirrored or modeled the real world was seen as a major benefit. Over time, the idea became less plausible, first because object-oriented programming took on more arcane forms moving further away from domain structures (under the influence of the Gang of Four patterns and other advanced programming techniques), and second because the inherent implementation bias in object-oriented design became clearer. The key problem is that, in the real world, the properties and behavior of objects involve relationships between them, and can rarely be satisfactorily assigned to individual objects. In practice, this is usually addressed by defining objects that hold relationships between other objects, but such a style is not really object-oriented. Worse, objects cannot generally be defined independently of one another (and in fact, as explained in the book, tend to produce code dependences that violate Parnas\u0026rsquo;s principles).\n  Domain-driven design. DDD is a very popular and successful approach to software development, created by Eric Evans. It can be viewed as a modern incarnation of the idea of building a software system on an explicit model of its problem domain, which goes back to Simula and JSD. A key innovation of DDD is the idea of \u0026ldquo;bounded context\u0026rdquo;: that each system or app has its own domain model, which serves its own functionality, reflects the world view of its development team, and may differ from (and even be inconsistent with) the domain models of other systems that operate in the same (larger) domain. Concept design proposes a more fine-grained structure, focusing on modularity within an app, each concept in a sense having its own bounded context (defined by its state/data model). In addition to the domain modeling aspect, DDD embodies an extensive collection of patterns and practices for building more flexible software. One pattern in particular suggests you \u0026ldquo;look for the underlying conceptual contours\u0026rdquo;, and it seems likely that concept design should thus be a good match for DDD. Finally, one key difference: a domain-driven design typically starts by constructing a model of the specific domain in a bottom-up fashion; one popular approach called \u0026ldquo;event storming\u0026rdquo; starts by classifying key events in the domain (just as JSD did). Concept design instead starts with recognizing standard concepts that can be assembled for the app at hand, and thus places more emphasis on reuse of domain models. This difference should not be fundamental however, and it seems likely that the two approaches could be used profitably together.\n  Feature-oriented development. Features are increments of functionality; a feature model comprises a set of features and constraints on which subsets of features can be combined together, implicitly defining a product family. Feature-based frameworks (such as Don Batory\u0026rsquo;s AHEAD tool suite) automate the configuring of features and merging of code fragments. In contrast to concepts, features are more flexible, and can not only model arbitrary increments of functionality but can also address aspects of a system that are not user-facing; a caching feature, for example, might improve performance without producing any observable change in behavior. The price paid is that features, unlike concepts, are not generally independent of one another, and cannot be easily reused across applications.\n  Cross-object modularity mechanisms. A variety of mechanisms have been developed to accommodate functionality that cross-cuts the traditional object boundaries in OO programming. These include aspect-oriented programming, subject-oriented programming and role-based programming. The latter two are similar to concepts in factoring out behaviors that serve distinct purposes, separating them from the existence of particular objects. Unlike concepts, however, these notions are not generally independent of one another, and (like features) are intended to be implemented in the context of a particular system and not transportable between systems.\n  Feature interaction. In the context of telephony, \u0026ldquo;features\u0026rdquo; have a different connotation, and are (like concepts) user facing and typically intended to be independent of one another. The \u0026ldquo;feature interaction\u0026rdquo; problem arises when a system includes features that prescribe conflicting behaviors. In concept design terms, feature interaction is a violation of integrity, and would be resolved by not allowing conflicting features to be active at the same time. This is one approach taken in telephony, but more flexible approaches are taken too (for example, giving priority to one feature over another). This flexibility might be achieved with concepts by designing concepts with non-determinism that can be resolved in composition.\n  Microservices. Most backend applications are nowadays structured as a collection of \u0026ldquo;microservices\u0026rdquo;, each providing an API and its own internal logic and storage. A concept can be viewed, at least from a functionality perspective, as a \u0026ldquo;nanoservice\u0026rdquo;—like a microservice but with a much more limited scope (with a single focused purpose rather than a collection of purposes around some area of functionality such as billing or advertising). Microservices are not generally independent of one another, and because they aggregate app-specific collections of functions, are not reusable across apps.\n  Strategies Each chapter of the book includes an outline at the end of some practical strategies, and a final chapter presents a set of questions for each kind of person (program manager, consultant, UX designer, etc) who might use concept design. Here are some highlights of ways to use concept design in your work:\n Design concepts for a new app, or for new functionality in an existing app, using the concept design structure, formulating purposes and operational principles to bring design focus. Avoid reinventing the wheel when designing an app, by always looking for ways in which existing, familiar concepts might suffice (and by spotting concepts that are small variations away from familiar concepts). Inventory the concepts in your app (or app family) to get a bird\u0026rsquo;s eye view of its functionality. Construct a dependence diagram to show what subsets are possible. Do this as a retrospective review of an existing app, in designing a new app, or in planning extensions or digital transformations. Identify concepts that are the most valuable (eg, product differentiators), the most troublesome (in terms of user confusion/complaints, development costs, etc), the least valuable (which might be dropped or replaced by more powerful concepts), etc. Genericize one or more concepts by reformulating its purpose independently of the type of objects it works on, and consider how making it more polymorphic might allow it to be simplified and applied in more contexts within your app (and across your app family or suite). Decompose concepts that serve multiple purposes into single-purpose concepts that are synchronized together. Find familiar concepts lurking behind the concepts of your app, and adjust your concepts or decompose them to expose familiar concepts that will make the app more intelligible to users. Look for synchronization opportunities that would increase the degree of automation in your app; conversely look for ways in which synchronization is excessive and eliminates manual controls that users would welcome. Identify redundant concepts that could be removed by being replaced by existing concepts (which may need some enrichment). Identify overloaded concepts that are complex or brittle, and split them into separate concepts. When users have trouble understanding your app, first consider overloading as a possible cause. Examine the data model or schema of your app and consider how you might decompose it into the local data models of individual concepts. Create help and training materials that are concept-driven so they can be grasped more easily by users: follow the dependence diagram for ordering; use consistent names for a concept throughout; note when a familiar concept is being used; present concepts with purposes and operational principles first (before the details of all their actions).  Fun things The end notes include mini-essays on some serious topics, including:\n Empiricism and its pitfalls Design thinking and \u0026ldquo;content-free\u0026rdquo; process Verification and its pernicious consequences Christopher Alexander, patterns and misfits Inevitability as a design criterion Mental models and gulfs of evaluation and execution Normal and radical design The pitfalls of object-oriented programming  and also include some lighter topics such as:\n My favorite pasta sauce recipe How to prevent ice dams and water leaks in your house An Easter egg in Don Norman\u0026rsquo;s book Why pixels and inches in CSS don\u0026rsquo;t mean what you think  Comments \u0026amp; reactions? Join the discussion at forum.softwareconcepts.io!\n","permalink":"https://essenceofsoftware.com/posts/distillation/","summary":"Save yourself the trouble of actually reading the book.","title":"The Essence of the Essence"},{"content":"Here is a lovely sketchnote by the wonderful artist and designer MJ Broadbent, which she created live during a keynote I gave about concept design at the SATURN conference in 2016. Concept design has come a long way since then, but many of the key ideas are here.\n  ","permalink":"https://essenceofsoftware.com/posts/sketchnote/","summary":"Early concept design ideas, drawn by MJ Broadbent.","title":"Concept Design Sketchnote"},{"content":"Yes, I know you get too much email too. But I wanted a chance to be in touch with people who are interested in concept design, so if you\u0026rsquo;d like to be included in my occasional mailings:\n\n","permalink":"https://essenceofsoftware.com/posts/subscribe/","summary":"Join an ultra-low-volume email list to hear new ideas about concepts and design.","title":"Design Updates in Your Mailbox"},{"content":"Concepts provide a framework for recording design experience. Designers often find themselves reinventing the wheel, designing and deploying concepts that have been built many times before, and then rediscovering a raft of subtle problems that were already known.\nMy dream is to have a concept catalog (or a collection of concept catalogs, perhaps organized by domains) that would hold a collection of concept definitions, and with each the accumulated experience and design wisdom from previous deployments of that concept.\nAs an example of what such a catalog entry might look like, here is a sample entry for the Upvote concept. Comments, suggestions and reactions welcome in the forum topic for this example.\nThis idea is inspired, of course, by the success of design patterns in programming.\nName: Upvote [Item, User]\nPurpose: Track relative popularity of items\nAlso known as: Like\nRelated concepts:\nReaction (send emotional reaction to author of post)\nRecommendation (track user approvals for future recommendations)\nModerate (maintain quality of forum by approving submissions)\nKarma (grant privileges to users based on good behavior)\nFlag (crowdsource moderation by having users mark bad items)\nState:\nupvotes, downvotes: Item -\u0026gt; set User count: Item -\u0026gt; one Int // item's count is defined as number of ups minus downs // all i: Item | i.count = #i.upvotes - #i.downvotes  Actions:\n\u2028upvote (i: Item, u: User)\u2028u not in i.upvotes i.upvotes += u i.downvotes -= u downvote (i: Item, u: User)\u2028u not in i.downvotes i.downvotes += u i.upvotes -= u unvote (i: Item, u: User)\u2028u in i.(upvotes+downvotes) i.upvotes -= u i.downvotes -= u  Operational principle:\nafter a sequence of upvote and downvote actions, the count of an item is equal to the number of users who upvoted minus the number who downvoted  General notes\nSyntax. Since this is the first concept that I\u0026rsquo;m adding to the catalog, here are a few notes on the syntax I\u0026rsquo;m using. This is the structure I use in EOS, but with more formal definitions of the actions. I\u0026rsquo;m using Alloy-like syntax for expressions and statements, which is hopefully intuitive even to those unfamiliar with Alloy. The state and actions part of the concept model is not new to concept design; it\u0026rsquo;s just a definition of a state machine activated by atomic actions as you\u0026rsquo;d find in any formal modeling language (such as TLA+, B, Z, VDM, OCL).\nDeclarations. The declaration r: A -\u0026gt; B declares a relation from A to B, constrained by any multiplicities (using the keywords one for exactly one, lone for zero or one, some for one or more, and set for zero or more).\nAction definitions. Action definitions can include constraints on the pre-state, as well as update statements. For example, in upvote, the first line is a precondition saying that you can\u0026rsquo;t upvote an item if you\u0026rsquo;ve already upvoted it. An update statement changes a relation, using +/- for adding and removing tuples. For example, in upvote, the second line says that the set of users associated with the item i in the upvotes relation is increased by u (or, equivalently, the tuple i-\u0026gt;u is added to the relation).\nType parameters. The list of types after the name of the concept gives the type parameters. These are types that are polymorphic, and can be bound to other types when the concept is composed. In this case, all the types are parameters. The Item type, for example, may be bound to Comment or Post in another concept, and the User type may be bound to any kind of principal (as the term is used in the security community).\nOperational principle. The OP is given informally. As explained in EOS, it\u0026rsquo;s an archetypal scenario, and unlike use cases, doesn\u0026rsquo;t need to cover all the functionality (so note that unvote is not mentioned). In this case, it looks a bit pathological because the concept is pretty simple: it basically just counts votes.\nDesign issues\nNegative count. This design allows counts to go negative. An alternative is to make a minimum of zero (even if the number of downvotes is still tracked implicitly).\nUnvote as own action. In some deployments, you may use downvote to let a user reverse their upvote action instead of unvote, but this won\u0026rsquo;t work if downvoting is limited (eg, by Karma) to certain users (as in Hacker News).\nUsing count. The count of an item can be used in different ways. Often it is shown to users, and is used to determine the rank order in which items appear. Sometimes the count is used directly for item ordering (as in comments in the NY Times), but more complex schemes are common: in Hacker News, for example, the rank of a post is computed from the number of points, the post\u0026rsquo;s age, and other factors.\nPreventing double voting. This design prevents a user from voting twice on a single item. In practice, this requires either tracking the identity of the user (eg, with session tokens), or by using a proxy for the user, such as the IP address, MAC address or browser id.\nVisibility. Usually only the count relation (and not the upvotes and downvotes relations) is made visible, so users cannot see who voted for an item. For Facebook \u0026ldquo;likes\u0026rdquo;, usernames are visible, but that can be seen as an artifact of combining the Upvote concept with the Reaction concept.\nEventual consistency. Getting exact counts is generally not required, so common implementations scale by not requiring strong consistency. This means that a user who upvotes an item will generally see that item\u0026rsquo;s count increase, but may not see the effect of a simultaneous (or even earlier) upvote from another user until later.\nKnown uses. Universally used in all social media apps, typically for posts and comments. Facebook combines the Upvote, Reaction and Recommendation concepts into a single \u0026ldquo;Like\u0026rdquo; concept, with some confusing outcomes (for example, that an angry reactions counts as an upvote).\nSynchronizations. Commonly synchronized with authoring concepts (such as Comment and Post), and with Karma (where an upvote may be synchronized with a reward action, so that a user needs to obtain some number of upvotes before reaching a certain karma level).\n","permalink":"https://essenceofsoftware.com/posts/upvote/","summary":"An example of a concept catalog entry that defines a concept\u0026rsquo;s purpose, behavior and design issues.","title":"Upvote: An Example Concept"},{"content":"I\u0026rsquo;m excited to have been invited by the ACM Practitioner Board to give a tech talk at noon Eastern Time on Dec 1, 2021.\n  Update: recording of the talk here\nThe Essence of Software (Or Why Systems Often Fail by Design, and How to Fix Them)\nWe’ve made great strides in software, but many systems are still hard to use or behave badly. Traditionally, we’ve looked to bugs in code to explain why systems go wrong—or to flaws in the user interface that may lead to misuse. In this talk, I’ll argue that the real problem often lies elsewhere: in the very concepts of the design. I’ll present a variety of surprising snags with familiar applications, from Dropbox to Gmail, and I’ll show how concepts can diagnose them and suggest fixes. I’ll explain in concrete and actionable terms what concepts are—essentially free-standing “nanoservices” that factor the behavior of a system into independent and reusable parts—and how you can apply them in your work, whether you’re a coder, program manager, software architect, UX designer, or consultant.\n","permalink":"https://essenceofsoftware.com/posts/acm-tech-talk/","summary":"Now updated with talk recording.","title":"ACM tech talk"},{"content":"You can download a free sample chapter from the book here.\n","permalink":"https://essenceofsoftware.com/posts/sample-chapter/","summary":"Download a free sample chapter.","title":"Sample book chapter"}]